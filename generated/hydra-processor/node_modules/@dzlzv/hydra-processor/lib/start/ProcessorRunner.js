"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessorRunner = void 0;
const MappingsProcessor_1 = require("../process/MappingsProcessor");
const debug_1 = require("debug");
const hydra_common_1 = require("@dzlzv/hydra-common");
const console_1 = require("console");
const dal_1 = require("../db/dal");
const typedi_1 = require("typedi");
const prometheus_1 = require("../prometheus");
const debug = debug_1.default('index-builder:manager');
// Respondible for creating, starting up and shutting down the query node.
// Currently this class is a bit thin, but it will almost certainly grow
// as the integration logic between the library types and the application
// evolves, and that will pay abstraction overhead off in terms of testability of otherwise
// anonymous code in root file scope.
class ProcessorRunner {
    constructor() {
        // TODO: a bit hacky, but okay for now
        debug(`Hydra processor lib version: ${process.env.npm_package_dependencies__dzlzv_hydra_processor || 'UNKNOWN'}`);
        // Hook into application
        // eslint-disable-next-line
        process.on('exit', () => ProcessorRunner.cleanUp().catch((e) => console_1.log(`${hydra_common_1.logError(e)}`)));
    }
    /**
     * Starts the mappings processor
     *
     * @param options options passed to create the mappings
     */
    async process(options) {
        const extraEntities = options.entities ? options.entities : [];
        await dal_1.createDBConnection(extraEntities);
        typedi_1.default.set('ProcessorOptions', options);
        const processor = new MappingsProcessor_1.MappingsProcessor(options);
        typedi_1.default.set('MappingsProcessor', processor);
        try {
            const promClient = new prometheus_1.ProcessorPromClient();
            promClient.init();
            prometheus_1.startPromEndpoint();
        }
        catch (e) {
            console.error(`Can't start Prometheus endpoint: ${hydra_common_1.logError(e)}`);
        }
        await processor.start();
    }
    /**
     * Run migrations in the "migrations" folder;
     */
    static async migrate() {
        let connection;
        try {
            connection = await dal_1.createDBConnection();
            if (connection)
                await connection.runMigrations();
        }
        finally {
            if (connection)
                await connection.close();
        }
    }
    static async cleanUp() {
        debug('Nothing to clean up');
    }
}
exports.ProcessorRunner = ProcessorRunner;
//# sourceMappingURL=ProcessorRunner.js.map