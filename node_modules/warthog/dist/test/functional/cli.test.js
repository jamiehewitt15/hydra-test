"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var gluegun_1 = require("gluegun");
// eslint-disable-next-line
// @ts-ignore
var pgtools = require("pgtools");
var pgtoolsCreateDB = pgtools.createdb;
var pgtoolsDropDB = pgtools.dropdb;
var helpers_1 = require("../helpers");
var server_vars_1 = require("../server-vars");
var root = gluegun_1.filesystem.path(__dirname, '../../../');
var GENERATED_FOLDER = path.join(__dirname, '../../../tmp/cli-tests');
describe('cli functional tests', function () {
    var spy = helpers_1.spyOnStd(); // Gives us access to whatever is written to stdout as part of the CLI command
    var openMock = jest.fn();
    beforeAll(function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, gluegun_1.filesystem.dirAsync(GENERATED_FOLDER)];
                case 1:
                    _a.sent(); // cleanup test artifacts
                    jest.mock('open', function () { return openMock; });
                    return [2 /*return*/];
            }
        });
    }); });
    beforeEach(function () {
        server_vars_1.setTestServerEnvironmentVariables();
        spy.clear();
    });
    afterAll(function () {
        gluegun_1.filesystem.remove(GENERATED_FOLDER); // cleanup test artifacts
        gluegun_1.filesystem.remove(path.join(__dirname, 'tmp'));
        openMock.mockReset();
    });
    // This test actually calls the CLI via a system call.  This won't count towards test coverage
    // but it's the most thorough way we can actually check to see if everything is wired up correctly
    test('spin up an actual process to test the full cli is wired up', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var env, output;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    expect.assertions(2);
                    env = __assign({}, process.env);
                    return [4 /*yield*/, gluegun_1.system.run('node ' + gluegun_1.filesystem.path(root, 'bin', 'warthog') + ' --version', {
                            env: env
                        })];
                case 1:
                    output = _a.sent();
                    // TODO: should we bother with this since we don't update the version in package.json?
                    expect(output).toContain('0.0.0-development');
                    // This makes sure we're actually getting the version command and not the standard "help" command, which also includes the version
                    expect(output).not.toContain('help');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('outputs help', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, helpers_1.callWarthogCLI('--help')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain('generate (g)');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('generates models', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout, fileContents;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    expect.assertions(23);
                    return [4 /*yield*/, helpers_1.callWarthogCLI("generate user name! nickname numLogins:int! verified:bool! registeredAt:date balance:float! meta:json! --folder " + GENERATED_FOLDER)];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain("Generated file at " + GENERATED_FOLDER + "/user.model.ts");
                    fileContents = gluegun_1.filesystem.read(GENERATED_FOLDER + "/user.model.ts");
                    expect(fileContents).toContain('export class User');
                    expect(fileContents).toContain('@StringField()');
                    expect(fileContents).toContain('name!: string;');
                    // This also checks that prettier was run to remove trailing comma
                    expect(fileContents).toContain('@StringField({ nullable: true })');
                    expect(fileContents).toContain('nickname?: string;');
                    expect(fileContents).toContain('@IntField()');
                    expect(fileContents).toContain('numLogins!: number;');
                    expect(fileContents).toContain('@BooleanField()');
                    expect(fileContents).toContain('verified!: boolean;');
                    // This also checks that prettier was run to remove trailing comma
                    expect(fileContents).toContain('@DateField({ nullable: true })');
                    expect(fileContents).toContain('registeredAt?: Date;');
                    expect(fileContents).toContain('@FloatField()');
                    expect(fileContents).toContain('balance!: number;');
                    // Generator should dynamically add these imports
                    expect(fileContents).toContain('BooleanField,');
                    expect(fileContents).toContain('DateField,');
                    expect(fileContents).toContain('FloatField,');
                    expect(fileContents).toContain('IntField,');
                    expect(fileContents).toContain('JSONField,');
                    expect(stdout).toContain("Generated file at " + GENERATED_FOLDER + "/user.service.ts");
                    fileContents = gluegun_1.filesystem.read(GENERATED_FOLDER + "/user.service.ts");
                    expect(fileContents).toContain("@Service('UserService')");
                    expect(stdout).toContain("Generated file at " + GENERATED_FOLDER + "/user.resolver.ts");
                    fileContents = gluegun_1.filesystem.read(GENERATED_FOLDER + "/user.resolver.ts");
                    expect(fileContents).toContain('this.service.find<UserWhereInput>');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('generates a shell of a file of no params specified', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout, fileContents;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    expect.assertions(9);
                    return [4 /*yield*/, helpers_1.callWarthogCLI("generate empty_class --folder " + GENERATED_FOLDER)];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain("Generated file at " + GENERATED_FOLDER + "/empty-class.model.ts");
                    fileContents = gluegun_1.filesystem.read(GENERATED_FOLDER + "/empty-class.model.ts");
                    expect(fileContents).toContain('export class EmptyClass extends BaseModel');
                    expect(fileContents).toContain('@StringField({ nullable: true })');
                    expect(fileContents).toContain('fieldName?: string;');
                    // Generator should NOT dynamically add these imports
                    expect(fileContents).not.toContain('BooleanField');
                    expect(fileContents).not.toContain('DateField');
                    expect(fileContents).not.toContain('FloatField');
                    expect(fileContents).not.toContain('IntField');
                    expect(fileContents).not.toContain('JSONField');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('generates to a dynamic path', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout, file, fileContents;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    expect.assertions(2);
                    return [4 /*yield*/, helpers_1.callWarthogCLI('generate empty_class --folder ' + GENERATED_FOLDER + '/${camelName}')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    file = GENERATED_FOLDER + "/emptyClass/empty-class.model.ts";
                    expect(stdout).toContain("Generated file at " + file);
                    fileContents = gluegun_1.filesystem.read(file);
                    expect(fileContents).toContain('export class EmptyClass extends BaseModel');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('requires name for db:create', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    expect.assertions(1);
                    // process.env.PGUSER = 'postgres';
                    return [4 /*yield*/, helpers_1.callWarthogCLI('db:create', { WARTHOG_DB_DATABASE: '' })];
                case 1:
                    // process.env.PGUSER = 'postgres';
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain('Database name is required');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('successfully creates a database', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    pgtools.createdb = jest.fn().mockImplementation(function (config, dbname, cb) {
                        cb(null, { success: true });
                    });
                    return [4 /*yield*/, helpers_1.callWarthogCLI('db:create')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain("Database 'warthog-test' created!");
                    pgtools.createdb = pgtoolsCreateDB;
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('throws an error if pg library cant create DB', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    pgtools.createdb = jest.fn().mockImplementation(function (config, dbname, cb) {
                        cb({ message: 'duplicate database' }, null);
                    });
                    return [4 /*yield*/, helpers_1.callWarthogCLI('db:create')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain("Database 'warthog-test' already exists");
                    pgtools.createdb = pgtoolsCreateDB;
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('db:drop: throws an error if database does not exist', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    pgtools.dropdb = jest.fn().mockImplementation(function (config, dbname, cb) {
                        cb({ name: 'invalid_catalog_name' }, null);
                    });
                    return [4 /*yield*/, helpers_1.callWarthogCLI('db:drop')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain("Database 'warthog-test' does not exist");
                    pgtools.dropdb = pgtoolsDropDB;
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('db:drop success', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    pgtools.dropdb = jest.fn().mockImplementation(function (config, dbname, cb) {
                        cb(null, { success: true });
                    });
                    return [4 /*yield*/, helpers_1.callWarthogCLI('db:drop')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain("Database 'warthog-test' dropped!");
                    pgtools.dropdb = pgtoolsDropDB;
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('db:drop success', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, helpers_1.callWarthogCLI('db:migrate:generate')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain('"name" option is required');
                    spy.clear();
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('generates and runs migrations', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var migrationDBName, stdout, migrationDir, migrationFileName, migrationContents;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    migrationDBName = 'warthog-test-generate-migrations';
                    // Set environment variables for a test server that writes to a separate test DB and does NOT autogenerate files
                    server_vars_1.setTestServerEnvironmentVariables({
                        WARTHOG_DB_DATABASE: migrationDBName,
                        WARTHOG_DB_SYNCHRONIZE: 'false'
                    });
                    return [4 /*yield*/, allowError(helpers_1.dropDB(migrationDBName), 'DropDB will likely fail since DB might not be there')];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, helpers_1.createDB(migrationDBName)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, helpers_1.callWarthogCLI('db:migrate:generate --name cli_test_db_migration')];
                case 3:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain('-CliTestDbMigration.ts');
                    expect(stdout).toContain('has been generated successfully.');
                    migrationDir = String(process.env.WARTHOG_DB_MIGRATIONS_DIR);
                    migrationFileName = fs.readdirSync(migrationDir)[0];
                    migrationContents = fs.readFileSync(path.join(migrationDir, migrationFileName), 'utf-8');
                    expect(migrationContents).toContain('CREATE TABLE "kitchen_sinks"');
                    expect(migrationContents).toContain('CREATE TABLE "dishs"');
                    expect(migrationContents).toContain('DROP TABLE "dishs"');
                    expect(migrationContents).toContain('DROP TABLE "kitchen_sinks"');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('warthog (with no command)', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var stdout;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, helpers_1.callWarthogCLI('')];
                case 1:
                    _a.sent();
                    stdout = spy.getStdOutErr();
                    expect(stdout).toContain('Warthog: GraphQL API Framework');
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('warthog playground', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, helpers_1.callWarthogCLI('playground')];
                case 1:
                    _a.sent();
                    expect(openMock).toBeCalledWith('http://localhost:4000/playground', { wait: false });
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('codegen creates correct files', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var folder, bindingContents, classContents, indexContents, ormConfigContents, schemaContents;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    folder = './tmp/codegen';
                    gluegun_1.filesystem.remove(folder);
                    process.env.WARTHOG_GENERATED_FOLDER = folder;
                    return [4 /*yield*/, helpers_1.callWarthogCLI('codegen')];
                case 1:
                    _a.sent();
                    bindingContents = gluegun_1.filesystem.read(folder + "/binding.ts");
                    expect(bindingContents).toContain('export interface Binding');
                    classContents = gluegun_1.filesystem.read(folder + "/classes.ts");
                    expect(classContents).toContain('export enum KitchenSinkOrderByEnum');
                    indexContents = gluegun_1.filesystem.read(folder + "/index.ts");
                    expect(indexContents).toContain("export * from './classes';");
                    ormConfigContents = gluegun_1.filesystem.read(folder + "/ormconfig.ts");
                    expect(ormConfigContents).toContain('module.exports = getBaseConfig();');
                    schemaContents = gluegun_1.filesystem.read(folder + "/schema.graphql");
                    expect(schemaContents).toContain('input KitchenSinkWhereInput');
                    gluegun_1.filesystem.remove(folder);
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
    test('warthog new', function (done) { return __awaiter(void 0, void 0, void 0, function () {
        var tmpFolder, packageJson, caretDep;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tmpFolder = path.join(__dirname, 'tmp');
                    // delete folder first
                    return [4 /*yield*/, helpers_1.callWarthogCLI('new foo', { WARTHOG_CLI_GENERATE_PATH: tmpFolder })];
                case 1:
                    // delete folder first
                    _a.sent();
                    packageJson = require(path.join(__dirname, 'tmp', 'package.json'));
                    caretDep = /^\^\d+/;
                    expect(packageJson.dependencies['dotenv']).toMatch(caretDep);
                    expect(packageJson.dependencies['reflect-metadata']).toMatch(caretDep);
                    expect(packageJson.dependencies['warthog']).toMatch(caretDep);
                    expect(packageJson.devDependencies['@types/jest']).toMatch(caretDep);
                    expect(packageJson.devDependencies['dotenvi']).toMatch(caretDep);
                    expect(packageJson.devDependencies['jest']).toMatch(caretDep);
                    expect(packageJson.devDependencies['ts-jest']).toMatch(caretDep);
                    expect(packageJson.devDependencies['ts-node']).toMatch(caretDep);
                    expect(packageJson.devDependencies['typescript']).toMatch(caretDep);
                    gluegun_1.filesystem.remove(tmpFolder);
                    done();
                    return [2 /*return*/];
            }
        });
    }); });
});
function allowError(promise, msg) {
    return __awaiter(this, void 0, void 0, function () {
        var error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, promise];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    console.log("Allowing error [" + msg + "]", error_1.message);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
//# sourceMappingURL=cli.test.js.map