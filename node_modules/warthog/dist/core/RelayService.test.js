"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Foo = void 0;
var typedi_1 = require("typedi");
var typeorm_1 = require("typeorm");
var __1 = require("../");
var encoding_1 = require("./encoding");
var RelayService_1 = require("./RelayService");
var Foo = /** @class */ (function (_super) {
    __extends(Foo, _super);
    function Foo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        __1.StringField(),
        __metadata("design:type", String)
    ], Foo.prototype, "name", void 0);
    Foo = __decorate([
        typeorm_1.Entity()
    ], Foo);
    return Foo;
}(__1.BaseModel));
exports.Foo = Foo;
describe('RelayService', function () {
    var relay = typedi_1.Container.get(RelayService_1.RelayService);
    var e = typedi_1.Container.get(encoding_1.EncodingService);
    var sortIdASC = { column: 'id', direction: 'ASC' };
    var sortIdDESC = { column: 'id', direction: 'DESC' };
    var sortCreatedAtASC = { column: 'createdAt', direction: 'ASC' };
    var sortCreatedAtDESC = { column: 'createdAt', direction: 'DESC' };
    var sortFooDESC = { column: 'foo', direction: 'DESC' };
    var foo = new Foo();
    foo.id = '1';
    foo.name = 'Foo';
    foo.createdAt = new Date('1981-10-15');
    var bar = new Foo();
    bar.id = '2';
    bar.name = 'Bar';
    bar.createdAt = new Date('1989-11-20');
    describe('toSortArray', function () {
        test('defaults to empty array', function () {
            expect(relay.toSortArray()).toEqual([]);
        });
        test('turns a sort into a Sort array', function () {
            expect(relay.toSortArray(sortIdASC)).toStrictEqual([sortIdASC]);
        });
        test('works with ID sort DESC', function () {
            expect(relay.toSortArray('id_DESC')).toEqual([sortIdDESC]);
        });
        test('works with non-ID sorts', function () {
            expect(relay.toSortArray('createdAt_ASC')).toEqual([sortCreatedAtASC]);
        });
        test('works with an array input including ID', function () {
            expect(relay.toSortArray(['createdAt_ASC', 'id_DESC'])).toEqual([
                sortCreatedAtASC,
                sortIdDESC
            ]);
        });
        test('works with an array input not including ID', function () {
            expect(relay.toSortArray(['createdAt_ASC', 'foo_DESC'])).toEqual([
                sortCreatedAtASC,
                sortFooDESC
            ]);
        });
    });
    describe('normalizeSort', function () {
        test('defaults to ID', function () {
            expect(relay.normalizeSort()).toStrictEqual([sortIdASC]);
        });
        test('Adds ID to sort', function () {
            expect(relay.normalizeSort(sortFooDESC)).toEqual([sortFooDESC, sortIdASC]);
        });
        test('Does not add ID to sort if already sorting by ID', function () {
            expect(relay.normalizeSort(sortIdASC)).toStrictEqual([sortIdASC]);
            expect(relay.normalizeSort(sortIdDESC)).toStrictEqual([sortIdDESC]);
        });
    });
    describe('encodeCursorItem', function () {
        test('Works with Dates', function () {
            expect(relay.encodeCursor(foo, sortCreatedAtDESC)).toBe(e.encode(['1981-10-15T00:00:00.000Z', '1']));
        });
    });
    describe('encodeCursor', function () {
        test('Works with multiple sorts', function () {
            var sortNameASC = { column: 'name', direction: 'ASC' };
            expect(relay.encodeCursor(foo, [sortCreatedAtDESC, sortNameASC])).toBe(e.encode(['1981-10-15T00:00:00.000Z', 'Foo', '1']));
        });
    });
    describe('decodeCursor', function () {
        test('Works with multiple sorts', function () {
            var obj = relay.decodeCursor('W1siY3JlYXRlZEF0IiwiREVTQyIsIjE5ODEtMTAtMTVUMDA6MDA6MDAuMDAwWiJdLFsibmFtZSIsIkFTQyIsIkZvbyJdLFsiaWQiLCJBU0MiLCIxIl1d');
            expect(obj).toStrictEqual([
                ['createdAt', 'DESC', '1981-10-15T00:00:00.000Z'],
                ['name', 'ASC', 'Foo'],
                ['id', 'ASC', '1']
            ]);
        });
    });
    describe('getFirstAndLast', function () {
        test('throws if data has no items', function () {
            expect(function () {
                return relay.firstAndLast([], 10);
            }).toThrow();
        });
        test('Returns the same for first and last if 1 item', function () {
            expect(relay.firstAndLast([foo], 10)).toStrictEqual([foo, foo]);
        });
        test('Works for 2 items', function () {
            expect(relay.firstAndLast([foo, bar], 10)).toStrictEqual([foo, bar]);
        });
        test('Works for 3 items', function () {
            var baz = new Foo();
            baz.name = 'Baz';
            baz.createdAt = new Date('1981-10-15');
            // Since we always ask for 1 more than we need, `baz` gets chopped off here
            expect(relay.firstAndLast([foo, bar, baz], 2)).toStrictEqual([foo, bar]);
        });
    });
    describe('getPageInfo', function () {
        test('throws if data has no items', function () {
            expect(function () {
                return relay.getPageInfo([], sortCreatedAtASC, { first: 1 });
            }).toThrow();
        });
        test('Returns the same for first and last if 1 item', function () {
            var result = relay.getPageInfo([foo], sortCreatedAtASC, { first: 1 });
            var startDecoded = e.decode(result.startCursor);
            var endDecoded = e.decode(result.endCursor);
            expect(result.hasNextPage).toEqual(false);
            expect(result.hasPreviousPage).toEqual(false);
            expect(startDecoded).toEqual(['1981-10-15T00:00:00.000Z', '1']);
            expect(endDecoded).toEqual(['1981-10-15T00:00:00.000Z', '1']);
        });
        test('Works properly if youre on the last page', function () {
            var result = relay.getPageInfo([foo, foo, foo, foo, bar, foo], sortCreatedAtASC, {
                first: 5
            });
            var startDecoded = e.decode(result.startCursor);
            var endDecoded = e.decode(result.endCursor);
            expect(result.hasNextPage).toEqual(true);
            expect(result.hasPreviousPage).toEqual(false);
            expect(startDecoded).toEqual(['1981-10-15T00:00:00.000Z', '1']);
            expect(endDecoded).toEqual(['1989-11-20T00:00:00.000Z', '2']);
        });
        // TODO: Add tests for last/before
    });
    describe('effectiveOrder', function () {
        test('works with no sorts and first', function () {
            expect(relay.effectiveOrder(undefined, { first: 10 })).toEqual([sortIdASC]);
        });
        test('works with multiple sorts and first', function () {
            expect(relay.effectiveOrder('foo_DESC', { first: 10 })).toEqual([sortFooDESC, sortIdASC]);
        });
        test('works with no sorts and last (reversed)', function () {
            expect(relay.effectiveOrder(undefined, { last: 10 })).toEqual([sortIdDESC]);
        });
        test('works with multiple sorts and last (reversed)', function () {
            expect(relay.effectiveOrder('foo_ASC', { last: 10 })).toEqual([sortFooDESC, sortIdDESC]);
        });
    });
    describe('getFilters', function () {
        test('returns empty object if there is no cursor', function () {
            expect(relay.getFilters(undefined, { first: 1 })).toEqual({});
        });
        test('works for base ID case', function () {
            var cursor = relay.encodeCursor(foo, 'id_ASC');
            expect(relay.getFilters(undefined, { first: 1, after: cursor })).toEqual({
                OR: [{ id_gt: '1' }]
            });
        });
        test('works with non-id sort', function () {
            var sorts = 'name_DESC';
            var cursor = relay.encodeCursor(foo, sorts);
            expect(relay.getFilters(sorts, { first: 1, after: cursor })).toEqual({
                OR: [{ name_lt: 'Foo' }, { id_gt: '1', name_eq: 'Foo' }]
            });
        });
        test.only('works several sorts', function () {
            var sorts = ['createdAt_ASC', 'name_DESC', 'id_ASC'];
            var cursor = relay.encodeCursor(foo, sorts);
            expect(relay.getFilters(sorts, { first: 1, after: cursor })).toEqual({
                OR: [
                    { createdAt_gt: '1981-10-15T00:00:00.000Z' },
                    { createdAt_eq: '1981-10-15T00:00:00.000Z', name_lt: 'Foo' },
                    { createdAt_eq: '1981-10-15T00:00:00.000Z', name_eq: 'Foo', id_gt: '1' }
                ]
            });
        });
    });
});
//# sourceMappingURL=RelayService.test.js.map