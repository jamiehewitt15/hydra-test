"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SchemaParser_1 = require("./../../src/parse/SchemaParser");
const chai_1 = require("chai");
const SchemaDirective_1 = require("../../src/parse/SchemaDirective");
describe('SchemaParser', () => {
    it('should fail on non-existent file', () => {
        chai_1.expect(() => new SchemaParser_1.GraphQLSchemaParser('./non-existent')).to.throw('not found');
    });
    it('should find a top-level entity', () => {
        const schema = SchemaParser_1.GraphQLSchemaParser.buildSchema(`
            type Cat {
                meow: String!
            }
       `);
        chai_1.expect(SchemaParser_1.GraphQLSchemaParser.createObjectTypeDefinations(schema)).length(1, 'Should detect exactly one type');
    });
    it('should throw an error on invalid schema', () => {
        const schema = `
            _type Cat {
                meow: String!
            }`;
        chai_1.expect(() => SchemaParser_1.GraphQLSchemaParser.buildSchema(schema)).to.throw('Syntax Error');
    });
    it('should throw on unknown directive', () => {
        const schema = `
            type Cat {
                meow: String! @undeclared
            }`;
        chai_1.expect(() => SchemaParser_1.GraphQLSchemaParser.buildSchema(schema)).to.throw('Unknown directive');
    });
    it('should throw on wrong location', () => {
        const schema = `
            type Cat @${SchemaDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE} {
                meow: String! 
            }`;
        chai_1.expect(() => SchemaParser_1.GraphQLSchemaParser.buildSchema(schema)).to.throw('may not be used on OBJECT');
    });
    it('should throw on wrong argument', () => {
        const schema = `
            type Cat {
                meow: String! @${SchemaDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE}(qquery: "dfd")
            }`;
        chai_1.expect(() => SchemaParser_1.GraphQLSchemaParser.buildSchema(schema)).to.throw('"String!" is required');
    });
    it('should detect fields types and directives', () => {
        var _a, _b, _c, _d, _e;
        const schema = `
            type Cat {
                meow: String! @${SchemaDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE}(query: "dfd")
            }`;
        const gSchema = SchemaParser_1.GraphQLSchemaParser.buildSchema(schema);
        const typeNodes = SchemaParser_1.GraphQLSchemaParser.createObjectTypeDefinations(gSchema);
        chai_1.expect(typeNodes).length(1);
        const node = typeNodes[0];
        chai_1.expect((_e = (_d = (_c = (_b = (_a = node === null || node === void 0 ? void 0 : node.fields) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.directives) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.name) === null || _e === void 0 ? void 0 : _e.value).eq(`${SchemaDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE}`, 'Should find a directive');
    });
    // TODO: this test now failes because apparently __ prefixed types do not pass validation
    //
    // it('should detect fields types and directives', () => {
    //     const schema = `
    //         type __Skip {
    //             a: String!
    //         }`;
    //    const gSchema = GraphQLSchemaParser.buildSchema(schema);
    //    const typeNodes = GraphQLSchemaParser.createObjectTypeDefinations(gSchema)
    //    expect(typeNodes).length(0,'Should ignore __ prefixed types');
    // })
    it('should load file', () => {
        const parser = new SchemaParser_1.GraphQLSchemaParser('test/fixtures/single-type.graphql');
        chai_1.expect(parser.getObjectDefinations()).length(1, 'Should detect one type');
        chai_1.expect(parser.getFields(parser.getObjectDefinations()[0])).length(5, 'Should detect fields');
    });
    it('should visit directives', () => {
        const parser = new SchemaParser_1.GraphQLSchemaParser('test/fixtures/single-type.graphql');
        const names = [];
        const visitor = {
            visit: (path) => {
                path.map((n) => names.push(n.name.value));
            },
        };
        const directives = {};
        directives[`${SchemaDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE}`] = visitor;
        parser.dfsTraversal({
            directives,
        });
        chai_1.expect(names).members(['Membership', 'handle', `${SchemaDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE}`], 'Should detect full path');
    });
    // TODO: in order to allow multiple directives we need to switch off SDL validation
    // in the parser. So this test is comment for the future use
    //
    // it('should support multiple directives', () => {
    //     const parser = new GraphQLSchemaParser('test/fixtures/multiple-queries.graphql');
    //     const queries: string[] = [];
    //     const visitor: Visitor = {
    //         visit: (path) => {
    //             path.map((n: SchemaNode) => {
    //                 if (n.kind === 'Directive') {
    //                     queries.push((n.arguments?.[0].value as StringValueNode).value)
    //                 }
    //             });
    //         }
    //     }
    //     parser.dfsTraversal({
    //         directives: {
    //             "fullTextSearchable": visitor
    //         }
    //     });
    //     expect(queries).members(["handles1", "handles2"], "Should detect multiple queries on the same field");
    // })
});
