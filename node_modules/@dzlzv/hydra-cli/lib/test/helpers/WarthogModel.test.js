"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const chai_1 = require("chai");
const WarthogModel_1 = require("../../src/model/WarthogModel");
describe('WarthogModel', () => {
    let warthogModel;
    beforeEach(() => {
        warthogModel = model_1.createModel();
    });
    it('Should lookup entities', () => {
        chai_1.expect(warthogModel.lookupEntity('Thread')).eq(model_1.threadObjType, 'Should find Thread type');
        chai_1.expect(warthogModel.lookupEntity('Post')).eq(model_1.postObjType, 'Should find Post type');
        chai_1.expect(() => warthogModel.lookupEntity('NoSuchType')).throw('NoSuchType is undefined');
    });
    it('Should lookup fields', () => {
        const field = warthogModel.lookupField('Thread', 'initial_body_text');
        chai_1.expect(field.type).equals('String', 'Should lookup the field');
        chai_1.expect(() => warthogModel.lookupField('Thread', 'noexistent')).throw('No field');
    });
    it('Should add queries', () => {
        warthogModel.addQueryClause('test', 'initial_body_text', 'Thread');
        warthogModel.addQueryClause('test', 'initial_body_text', 'Post');
        chai_1.expect(warthogModel.ftsQueries).length(1, 'Should add a query');
        chai_1.expect(warthogModel.ftsQueries[0].clauses).length(2, 'Should add two clauses');
    });
    it('Should add enums', () => {
        const model = model_1.fromStringSchema(`
        enum Episode {
            NEWHOPE
            EMPIRE
            JEDI
        }
        
        type Movie @entity {
            episode: Episode
        }`);
        chai_1.expect(model.enums).length(1, 'Should add an enum');
        chai_1.expect(model.lookupEnum('Episode').name).eq('Episode', 'Should lookup by name');
    });
    it('Should add interfaces', () => {
        const model = model_1.fromStringSchema(`
        interface IEntity @entity {
            f: String
        }`);
        chai_1.expect(model.interfaces).length(1, 'Should add an interface');
        chai_1.expect(model.lookupInterface('IEntity').name).eq('IEntity', 'Should lookup by name');
        chai_1.expect(model.lookupInterface('IEntity').isInterface).eq(true, 'Should be an interface');
    });
    it('Should should ignore interfaces without @entity', () => {
        const model = model_1.fromStringSchema(`
        interface IEntity {
            f: String
        }`);
        chai_1.expect(model.interfaces).length(0, 'Should skip the non-annotated interface');
    });
    it('Should add interfaces to entities', () => {
        const model = model_1.fromStringSchema(`
        interface IEntity @entity {
            field1: String
        }
        type A implements IEntity @entity {
            field1: String
            field2: String
        }`);
        chai_1.expect(model.lookupEntity('A').interfaces).length(1, 'Should register the implemented interface');
    });
    it('Should lookup types', () => {
        const model = model_1.fromStringSchema(`
    union Poor = HappyPoor | Miserable
    type HappyPoor @variant {
      father: Poor!
      mother: Poor!
    }
    
    type Miserable @variant {
      hates: String!
    }
    
    type MyEntity @entity {
      status: Poor!
    }
    
    enum MyEnum {
      A
    }

    interface MyInterface @entity {
      xxx: String!
    }
    `);
        chai_1.expect(model.lookupType('MyEntity')).eq(WarthogModel_1.ModelType.ENTITY, 'Should detect entities');
        chai_1.expect(model.lookupType('HappyPoor')).eq(WarthogModel_1.ModelType.VARIANT, 'Should detect variants');
        chai_1.expect(model.lookupType('MyEnum')).eq(WarthogModel_1.ModelType.ENUM, 'Should detect enums');
        chai_1.expect(model.lookupType('MyInterface')).eq(WarthogModel_1.ModelType.INTERFACE, 'Should detect intefaces');
        chai_1.expect(model.lookupType('Poor')).eq(WarthogModel_1.ModelType.UNION, 'Should detect unions');
        chai_1.expect(model.lookupType('String')).eq(WarthogModel_1.ModelType.SCALAR, 'Should detect String as a scalar');
        chai_1.expect(model.lookupType('Boolean')).eq(WarthogModel_1.ModelType.SCALAR, 'Should detect Boolean as a scalar');
        chai_1.expect(model.lookupType('BigInt')).eq(WarthogModel_1.ModelType.SCALAR, 'Should detect BigInt as a scalar');
        chai_1.expect(model.lookupType('Bytes')).eq(WarthogModel_1.ModelType.SCALAR, 'Should detect Bytes as a scalar');
    });
    it('Should add variants and unions', () => {
        const model = model_1.fromStringSchema(`
    union Poor = HappyPoor | Miserable
    type HappyPoor @variant {
      father: Poor!
      mother: Poor!
    }
    
    type Miserable @variant {
      hates: String!
    }`);
        chai_1.expect(model.lookupUnion('Poor').name).eq('Poor', 'Should look up a union');
        chai_1.expect(model.lookupUnion('Poor').types).length(2, 'Should find two variant types');
        chai_1.expect(model.variants).length(2, 'Should find two variant types');
    });
    it('Should throw on non-variant union', () => {
        chai_1.expect(() => model_1.fromStringSchema(`
    union Poor = HappyPoor | Miserable
    type HappyPoor @variant {
      father: Poor!
      mother: Poor!
    }
    
    type Miserable @entity {
      hates: String!
    }`)).throw('Variant Miserable is undefined', 'Unions should allow only @variant types');
    });
    // TODO: Not yet implemented!
    //
    // it('Should throw on variant fields', () => {
    //   expect(() => fromStringSchema(`
    //   union Poor = HappyPoor | Miserable
    //   type HappyPoor @variant {
    //     father: Poor!
    //     mother: Poor!
    //   }
    //   type Miserable @variant {
    //     hates: String!
    //   }
    //   type MyEntity @entity {
    //     status: Miserable!
    //   }
    //   `)).throw('The field MyEntity.status cannot be of variant type', 'Variant types are not allowed in entity fields');
    // })
    it('Should add a union field to an entity', () => {
        const model = model_1.fromStringSchema(`
    union Poor = HappyPoor | Miserable
    type HappyPoor @variant {
      father: String!
      mother: String!
    }
    
    type Miserable @variant {
      hates: String!
    }
    
    type MyEntity @entity {
      status: Poor!
    }`);
        chai_1.expect(model.lookupEntity('MyEntity').fields[0].isUnion()).eq(true, 'Should have a single field of union type');
    });
});
