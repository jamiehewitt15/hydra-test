"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ModelRenderer_1 = require("../../src/generate/ModelRenderer");
const model_1 = require("../../src/model");
const model_2 = require("./model");
const fs = tslib_1.__importStar(require("fs-extra"));
const chai_1 = require("chai");
const debug_1 = tslib_1.__importDefault(require("debug"));
const EnumContextProvider_1 = require("../../src/generate/EnumContextProvider");
const debug = debug_1.default('cli-test:model-renderer');
describe('ModelRenderer', () => {
    let generator;
    let warthogModel;
    let modelTemplate;
    let enumCtxProvider;
    let resolverTemplate;
    before(() => {
        // set timestamp in the context to make the output predictable
        modelTemplate = fs.readFileSync('./src/templates/entities/model.ts.mst', 'utf-8');
        resolverTemplate = fs.readFileSync('./src/templates/entities/resolver.ts.mst', 'utf-8');
    });
    beforeEach(() => {
        warthogModel = model_2.createModel();
        enumCtxProvider = new EnumContextProvider_1.EnumContextProvider();
    });
    it('should transform fields to camelCase', function () {
        warthogModel.addField('Post', new model_1.Field('CamelCase', 'String'));
        warthogModel.addField('Post', new model_1.Field('snake_case', 'String'));
        warthogModel.addField('Post', new model_1.Field('kebab-case', 'String'));
        generator = new ModelRenderer_1.ModelRenderer(warthogModel, warthogModel.lookupEntity('Post'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include('camelCase?: string', 'Should camelCase correctly');
        chai_1.expect(rendered).to.include('snakeCase?: string', 'Should camelCase correctly');
        chai_1.expect(rendered).to.include('kebabCase?: string', 'Should camelCase correctly');
    });
    it('should render ClassName', function () {
        warthogModel.addEntity({
            name: `some_randomEntity`,
            isEntity: true,
            isVariant: false,
            fields: [new model_1.Field('a', 'String')],
        });
        generator = new ModelRenderer_1.ModelRenderer(warthogModel, warthogModel.lookupEntity('some_randomEntity'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include('export class SomeRandomEntity extends BaseModel', 'Should render ClassName corretly');
    });
    it('should include imports', function () {
        warthogModel.addField('Post', new model_1.Field('a', 'ID'));
        warthogModel.addField('Post', new model_1.Field('b', 'String'));
        warthogModel.addField('Post', new model_1.Field('c', 'Int'));
        warthogModel.addField('Post', new model_1.Field('d', 'DateTime'));
        warthogModel.addField('Post', new model_1.Field('e', 'Float'));
        warthogModel.addField('Post', new model_1.Field('f', 'BigInt'));
        warthogModel.addField('Post', new model_1.Field('g', 'BigDecimal'));
        warthogModel.addField('Post', new model_1.Field('h', 'Bytes'));
        warthogModel.addField('Post', new model_1.Field('j', 'Boolean'));
        generator = new ModelRenderer_1.ModelRenderer(warthogModel, warthogModel.lookupEntity('Post'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        chai_1.expect(rendered).to.include('BooleanField,', 'Should import BooleanField');
        chai_1.expect(rendered).to.include('DateTimeField,', 'Should import DateTimeField');
        chai_1.expect(rendered).to.include('FloatField,', 'Should import FloatField');
        chai_1.expect(rendered).to.include('IntField,', 'Should import IntField');
        chai_1.expect(rendered).to.include('NumericField,', 'Should import NumericField');
        chai_1.expect(rendered).to.include('BytesField,', 'Should import BytesField');
    });
    it('should render otm types', function () {
        const model = model_2.fromStringSchema(`
    type Author @entity {
      posts: [Post!] @derivedFrom(field: "author")
    }
    
    type Post @entity {
      title: String
      author: Author!
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Author'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include(`import { Post } from '../post/post.model`, `Should render imports`);
        chai_1.expect(rendered).to.include(`@OneToMany(() => Post, (param: Post) => param.author)`, 'Should render OTM decorator');
        chai_1.expect(rendered).to.include(`posts?: Post[];`, 'Should render plural references');
    });
    it('should render mto types', function () {
        const model = model_2.fromStringSchema(`
    type Author @entity {
      name: String!
    }
    
    type Post @entity {
      title: String
      author: Author! 
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Post'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include(`import { Author } from '../author/author.model`, `Should render imports`);
        chai_1.expect(rendered).to.include(`@ManyToOne(() => Author, (param: Author) => param.postauthor, { skipGraphQLField: true })`, 'Should render MTO decorator'); // nullable: true is not includered?
        chai_1.expect(rendered).to.include(`author!: Author;`, 'Should render required referenced field');
    });
    it('should add nullable option mto decorator', function () {
        const model = model_2.fromStringSchema(`
    type Channel @entity {
      handle: String!
      language: Language
    }
    
    type Language @entity {
      code: String!
      name: String!
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Channel'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include(`@ManyToOne(() => Language, (param: Language) => param.channellanguage, { skipGraphQLField: true, nullable: true })`, 'Should render MTO decorator with nullable option');
    });
    it('should renderer array types', function () {
        const model = model_2.fromStringSchema(`
    type Author @entity {
      posts: [String]
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Author'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include('CustomField,', 'Should import CustomField');
        chai_1.expect(rendered).to.include(`@CustomField`, 'Should decorate arrays with @CustomField');
        chai_1.expect(rendered).to.include(`db: { type: 'text', array: true, nullable: true }`, 'Should add db option');
        chai_1.expect(rendered).to.include(`api: { type: 'string', nullable: true }`, 'Should inclued api option');
        chai_1.expect(rendered).to.include('posts?: string[]', `should add an array field`);
    });
    it('should render enum types', function () {
        const model = model_2.fromStringSchema(`
      enum Episode {
        NEWHOPE
        EMPIRE
        JEDI
      }
        
      type Movie @entity {
        episode: Episode
      }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Movie'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include('EnumField,', 'Should import EnumField');
        chai_1.expect(rendered).to.include('export { Episode }', 'Should export enum');
        // this will be generated in ../enums/enum.ts
        // expect(rendered).to.include(`NEWHOPE = 'NEWHOPE'`, 'Should render enum values');
        chai_1.expect(rendered).to.include(`@EnumField`, 'Should decorate with @EnumField');
        chai_1.expect(rendered).to.include(`'Episode', Episode`);
        chai_1.expect(rendered).to.include(`nullable: true`, 'Should add enum decorator options');
        chai_1.expect(rendered).to.include(`episode?:`, 'Should add nullable');
    });
    it('should decorate field with the correct enum type', function () {
        const model = model_2.fromStringSchema(`
      enum episode_Camel_Case {
        NEWHOPE
        EMPIRE
        JEDI
      }
        
      type Movie @entity {
        episode: episode_Camel_Case
      }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Movie'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include(`import { episode_Camel_Case } from '../enums/enums'`, 'Should import enum');
        chai_1.expect(rendered).to.include('export { episode_Camel_Case }', 'Should export enum');
        // this will be generated in ../enums/enum.ts
        // expect(rendered).to.include(`NEWHOPE = 'NEWHOPE'`, 'Should render enum values');
        chai_1.expect(rendered).to.include(`'episode_Camel_Case', episode_Camel_Case,`, 'Should add enum decorator options');
        chai_1.expect(rendered).to.include(`nullable: true`, 'Should add enum decorator options');
        chai_1.expect(rendered).to.include(`episode?: episode_Camel_Case`, 'Should camelCase type');
    });
    it('should import and export both enums', function () {
        const model = model_2.fromStringSchema(`
      enum enum1 {
        NEWHOPE
        EMPIRE
        JEDI
      }

      enum enum2 {
        NEWHOPE
        EMPIRE
        JEDI
      }
        
      type Movie @entity {
        field1: enum1,
        field2: enum2
      }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Movie'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        debug(`rendered: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include(`import { enum1 } from '../enums/enums'`, 'Should import enum1');
        chai_1.expect(rendered).to.include('export { enum1 }', 'Should export enum1');
        chai_1.expect(rendered).to.include(`import { enum2 } from '../enums/enums'`, 'Should import enum2');
        chai_1.expect(rendered).to.include('export { enum2 }', 'Should export enum2');
    });
    it('should export enum from a single entity', function () {
        const model = model_2.fromStringSchema(`
      enum enum1 {
        NEWHOPE
        EMPIRE
        JEDI
      }
      
      type B @entity {
        field1: enum1,
      }

      type A @entity {
        field1: enum1,
      }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('A'), enumCtxProvider);
        let rendered = generator.render(modelTemplate);
        debug(`rendered A: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.include('export { enum1 }', 'Should export enum1');
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('B'), enumCtxProvider);
        rendered = generator.render(modelTemplate);
        debug(`rendered B: ${JSON.stringify(rendered, null, 2)}`);
        chai_1.expect(rendered).to.not.include('export { enum1 }', 'B should not export enum1');
    });
    it('should extend interface type', function () {
        const model = model_2.fromStringSchema(`
        interface IEntity @entity {
            field1: String
        }
        type A implements IEntity @entity {
            field1: String
            field2: String
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('A'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        chai_1.expect(rendered).to.include('extends IEntity');
        chai_1.expect(rendered).to.include(`import { IEntity } from '../i-entity/i-entity.model'`, 'should import interface type');
    });
    it('should not include interface field', function () {
        const model = model_2.fromStringSchema(`
        interface IEntity @entity {
            field1: String
        }
        type A implements IEntity @entity {
            field1: String
            field2: String
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('A'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        chai_1.expect(rendered).to.not.include('field1');
    });
    it('should render interface', function () {
        const model = model_2.fromStringSchema(`
        interface IEntity @entity {
            field1: String
        }
        type A implements IEntity @entity {
            field1: String
            field2: String
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupInterface('IEntity'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        chai_1.expect(rendered).to.include('@InterfaceType');
    });
    it('should import unions', function () {
        const model = model_2.fromStringSchema(`
    union Poor = HappyPoor | Miserable
    type HappyPoor @variant {
      father: Poor!
      mother: Poor!
    }
    
    type Miserable @variant {
      hates: String!
    }
    
    type MyEntity @entity {
      status: Poor!
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('MyEntity'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        chai_1.expect(rendered).to.include(`import { Poor } from '../variants/variants.model'`);
        // prettier put brackets aroung args
        chai_1.expect(rendered).to.include('(type) => Poor', 'Should render the correct union type');
        chai_1.expect(rendered).to.include('status!: typeof Poor', 'Should render the correct union type');
    });
    it('Should add transformer for BigInt fields', () => {
        const model = model_2.fromStringSchema(`
    type Tip @entity {
      value: BigInt!
    }
    `);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Tip'), enumCtxProvider);
        const rendered = generator.render(modelTemplate);
        chai_1.expect(rendered).to.include(`transformer`);
        chai_1.expect(rendered).to.include(`to: (entityValue: BN) => (entityValue !== undefined ? entityValue.toString(10) : null)`);
        chai_1.expect(rendered).to.include(`dbValue !== undefined && dbValue !== null && dbValue.length > 0 ? new BN(dbValue, 10) : undefined`);
    });
    it('Should add required object definations for Pagination', () => {
        const model = model_2.fromStringSchema(`
    type Member @entity {
      id: ID!
      handle: String!
    }
    `);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Member'), enumCtxProvider);
        const rendered = generator.render(resolverTemplate);
        chai_1.expect(rendered).to.include(`MemberEdge`);
        chai_1.expect(rendered).to.include(`MemberConnection`);
        chai_1.expect(rendered).to.include(`ConnectionPageInputOptions`);
        chai_1.expect(rendered).to.include(`MemberConnectionWhereArgs`);
        chai_1.expect(rendered).to.include(`membersConnection`);
        chai_1.expect(rendered).to.include(`findConnection<MemberWhereInput>`);
    });
    it('Should properly pluralize connection naming for camelCased names', () => {
        const model = model_2.fromStringSchema(`
    type VideoCategory @entity {
      id: ID!
    }

    type Video @entity {
      id: ID!
    }
    `);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('VideoCategory'), enumCtxProvider);
        const rendered = generator.render(resolverTemplate);
        chai_1.expect(rendered).to.include(`videoCategoriesConnection`);
        chai_1.expect(rendered).to.include(`async videoCategories`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Video'), enumCtxProvider);
        chai_1.expect(generator.render(resolverTemplate)).to.include(`videosConnection`);
        chai_1.expect(generator.render(resolverTemplate)).to.include(`async videos`);
    });
    it('Should add querying a single entity query', () => {
        const model = model_2.fromStringSchema(`
    type Channel @entity {
      id: ID!
      handle: String!
    }`);
        generator = new ModelRenderer_1.ModelRenderer(model, model.lookupEntity('Channel'), enumCtxProvider);
        const rendered = generator.render(resolverTemplate);
        chai_1.expect(rendered).to.include(`Query(() => Channel, { nullable: true })`);
        chai_1.expect(rendered).to.include(`async channel(@Arg('where') where: ChannelWhereUniqueInput, @Fields() fields: string[]): Promise<Channel | null>`);
        chai_1.expect(rendered).to.include(`this.service.find(where, undefined, 1, 0, fields)`);
    });
});
