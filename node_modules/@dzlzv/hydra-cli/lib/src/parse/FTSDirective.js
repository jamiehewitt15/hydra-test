"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FTSDirective = exports.FULL_TEXT_SEARCHABLE_DIRECTIVE = void 0;
const lodash_1 = require("lodash");
exports.FULL_TEXT_SEARCHABLE_DIRECTIVE = 'fulltext';
class FTSDirective {
    constructor() {
        this.preamble = `directive @${exports.FULL_TEXT_SEARCHABLE_DIRECTIVE}(query: String!) on FIELD_DEFINITION`;
        this.name = exports.FULL_TEXT_SEARCHABLE_DIRECTIVE;
    }
    validate(_path) {
        const path = lodash_1.cloneDeep(_path);
        if (path.length < 3) {
            throw new Error('The path should contain at least a type and field definition nodes');
        }
        const dirNode = path.pop();
        if ((dirNode === null || dirNode === void 0 ? void 0 : dirNode.kind) !== 'Directive') {
            throw new Error('The path should end at a directive node');
        }
        const fieldNode = path.pop();
        if ((fieldNode === null || fieldNode === void 0 ? void 0 : fieldNode.kind) !== 'FieldDefinition') {
            throw new Error('The directive should be applied to a field node');
        }
        let type = fieldNode.type;
        if (fieldNode.type.kind === 'NonNullType') {
            type = fieldNode.type.type;
        }
        if (type.kind === 'ListType') {
            throw new Error('Only single named types are supported');
        }
        if (type.kind !== 'NamedType') {
            throw new Error('Only single named types are supported');
        }
        if (type.name.value !== 'String') {
            throw new Error(`Only string types can be annotaed ${exports.FULL_TEXT_SEARCHABLE_DIRECTIVE}`);
        }
    }
    generate(path, model) {
        this.validate(path);
        const dirNode = path.pop();
        const fieldNode = path.pop();
        const objTypeNode = path.pop();
        const qName = this._checkFullTextSearchDirective(dirNode);
        model.addQueryClause(qName, fieldNode.name.value, objTypeNode.name.value);
        return model;
    }
    /**
     *
     * Does the checks and returns full text query names to be used;
     *
     * @param d Directive Node
     * @returns Fulltext query names
     */
    _checkFullTextSearchDirective(d) {
        if (!d.arguments) {
            throw new Error(`@${exports.FULL_TEXT_SEARCHABLE_DIRECTIVE} should have a query argument`);
        }
        const qarg = d.arguments.filter((arg) => arg.name.value === `query` && arg.value.kind === `StringValue`);
        if (qarg.length !== 1) {
            throw new Error(`@${exports.FULL_TEXT_SEARCHABLE_DIRECTIVE} should have a single query argument with a sting value`);
        }
        return qarg[0].value.value;
    }
}
exports.FTSDirective = FTSDirective;
