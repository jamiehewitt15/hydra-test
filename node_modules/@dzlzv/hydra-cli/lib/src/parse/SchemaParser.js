"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLSchemaParser = exports.DIRECTIVES = void 0;
const tslib_1 = require("tslib");
const graphql_1 = require("graphql");
const fs = tslib_1.__importStar(require("fs-extra"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const lodash_1 = require("lodash");
const constant_1 = require("./constant");
const FTSDirective_1 = require("./FTSDirective");
const debug = debug_1.default('qnode-cli:schema-parser');
exports.DIRECTIVES = [new FTSDirective_1.FTSDirective()];
/**
 * Parse GraphQL schema
 * @constructor(schemaPath: string)
 */
class GraphQLSchemaParser {
    constructor(schemaPath) {
        if (!fs.existsSync(schemaPath)) {
            throw new Error('Schema not found');
        }
        const contents = fs.readFileSync(schemaPath, 'utf8');
        this.schema = GraphQLSchemaParser.buildSchema(contents);
        this.namedTypes = [
            ...Object.values(this.schema.getTypeMap()).filter((t) => !t.name.startsWith('__') // filter out auxiliarry GraphQL types;
            ),
        ];
        this._objectTypeDefinations = GraphQLSchemaParser.createObjectTypeDefinations(this.schema);
    }
    static buildPreamble() {
        let preamble = constant_1.SCHEMA_DEFINITIONS_PREAMBLE;
        exports.DIRECTIVES.map((d) => (preamble += d.preamble + '\n'));
        return preamble;
    }
    /**
     * Read GrapqhQL schema and build a schema from it
     */
    static buildSchema(contents) {
        const schema = GraphQLSchemaParser.buildPreamble().concat(contents);
        const ast = graphql_1.parse(schema);
        // in order to build AST with undeclared directive, we need to
        // switch off SDL validation
        const schemaAST = graphql_1.buildASTSchema(ast);
        const errors = graphql_1.validateSchema(schemaAST);
        if (errors.length > 0) {
            // There are errors
            let errorMsg = `Schema is not valid. Please fix the following errors: \n`;
            errors.forEach((e) => (errorMsg += `\t ${e.name}: ${e.message}\n`));
            debug(errorMsg);
            throw new Error(errorMsg);
        }
        return schemaAST;
    }
    getEnumTypes() {
        return [
            ...this.namedTypes.filter((t) => t instanceof graphql_1.GraphQLEnumType),
        ];
    }
    getInterfaceTypes() {
        return [
            ...this.namedTypes.filter((t) => t instanceof graphql_1.GraphQLInterfaceType),
        ];
    }
    getUnionTypes() {
        return [
            ...this.namedTypes.filter((t) => t instanceof graphql_1.GraphQLUnionType),
        ];
    }
    /**
     * Get object type definations from the schema. Build-in and scalar types are excluded.
     */
    static createObjectTypeDefinations(schema) {
        return [
            ...Object.values(schema.getTypeMap())
                // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
                .filter((t) => !t.name.match(/^__/) && !t.name.match(/Query/)) // skip the top-level Query type
                .sort((a, b) => (a.name > b.name ? 1 : -1))
                .map((t) => t.astNode),
        ]
            .filter(Boolean) // Remove undefineds and nulls
            .filter((typeDefinationNode) => (typeDefinationNode === null || typeDefinationNode === void 0 ? void 0 : typeDefinationNode.kind) === 'ObjectTypeDefinition');
    }
    /**
     * Returns fields for a given GraphQL object
     * @param objDefinationNode ObjectTypeDefinitionNode
     */
    getFields(objDefinationNode) {
        if (objDefinationNode.fields)
            return [...objDefinationNode.fields];
        return [];
    }
    /**
     * Returns GraphQL object type definations
     */
    getObjectDefinations() {
        return this._objectTypeDefinations;
    }
    /**
     * DFS traversal of the AST
     */
    dfsTraversal(visitors) {
        // we traverse starting from each definition
        this._objectTypeDefinations.map((objType) => {
            const path = [];
            graphql_1.visit(objType, {
                enter: (node) => {
                    if (node.kind !== 'Directive' &&
                        node.kind !== 'ObjectTypeDefinition' &&
                        node.kind !== 'FieldDefinition') {
                        // skip non-definition fields;
                        return false;
                    }
                    path.push(node);
                    if (node.kind === 'Directive') {
                        if (node.name.value in visitors.directives) {
                            visitors.directives[node.name.value].visit(lodash_1.cloneDeep(path));
                        }
                    }
                },
                leave: () => path.pop(),
            });
        });
    }
}
exports.GraphQLSchemaParser = GraphQLSchemaParser;
