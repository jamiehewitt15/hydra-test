"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDerivedFields = exports.addDerivedFromIfy = void 0;
const constant_1 = require("./constant");
function addDerivedFromIfy(fieldDef, field) {
    var _a;
    const d = (_a = fieldDef.directives) === null || _a === void 0 ? void 0 : _a.find((d) => d.name.value === constant_1.DERIVED_FROM_DIRECTIVE);
    if (!d)
        return;
    if (!d.arguments) {
        throw new Error(`@${constant_1.DERIVED_FROM_DIRECTIVE} should have a field argument`);
    }
    const directiveArgs = d.arguments.find((arg) => arg.name.value === 'field' && arg.value.kind === 'StringValue');
    // TODO: graphql-js already throw error??
    if (!directiveArgs) {
        throw new Error(`@${constant_1.DERIVED_FROM_DIRECTIVE} should have a single field argument with a sting value`);
    }
    field.derivedFrom = {
        argument: directiveArgs.value.value,
    };
}
exports.addDerivedFromIfy = addDerivedFromIfy;
function validateDerivedFields(model) {
    model.entities.forEach((objType) => {
        objType.fields.forEach((f) => {
            var _a;
            if (!f.derivedFrom)
                return;
            if (f.isScalar()) {
                throw new Error('Derived field type is not an entity type');
            }
            if (!model.lookupField(f.type, (_a = f.derivedFrom) === null || _a === void 0 ? void 0 : _a.argument)) {
                throw new Error('Derived field does not exists on the related type');
            }
        });
    });
}
exports.validateDerivedFields = validateDerivedFields;
