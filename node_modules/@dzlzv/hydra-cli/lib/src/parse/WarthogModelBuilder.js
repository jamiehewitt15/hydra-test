"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WarthogModelBuilder = void 0;
const tslib_1 = require("tslib");
const SchemaParser_1 = require("./SchemaParser");
const model_1 = require("../model");
const debug_1 = tslib_1.__importDefault(require("debug"));
const constant_1 = require("./constant");
const FTSDirective_1 = require("./FTSDirective");
const ScalarTypes_1 = require("../model/ScalarTypes");
const DerivedFrom = tslib_1.__importStar(require("./DerivedFromDirective"));
const RelationshipGenerator_1 = require("../generate/RelationshipGenerator");
const debug = debug_1.default('qnode-cli:model-generator');
/**
 * Parse a graphql schema and generate model defination strings for Warthog. It use GraphQLSchemaParser for parsing
 * @constructor(schemaPath: string)
 */
class WarthogModelBuilder {
    constructor(schemaPath) {
        this._fieldsToProcess = [];
        this._schemaParser = new SchemaParser_1.GraphQLSchemaParser(schemaPath);
        this._model = new model_1.WarthogModel();
    }
    /**
     * Returns true if type is Scalar, String, Int, Boolean, Float otherwise false
     * Scalar types are also built-in
     */
    _isBuildinType(type) {
        return type in ScalarTypes_1.availableTypes;
    }
    _listType(typeNode, fieldName) {
        let field;
        if (typeNode.type.kind === 'ListType') {
            throw new Error('Only one level lists are allowed');
        }
        else if (typeNode.type.kind === 'NamedType') {
            field = this._namedType(fieldName, typeNode.type);
            field.isList = true;
        }
        else {
            if (typeNode.type.type.kind === 'ListType') {
                throw new Error('Only one level lists are allowed');
            }
            field = this._namedType(fieldName, typeNode.type.type);
            field.nullable = false;
        }
        field.isList = true;
        return field;
    }
    /**
     * Create a new Field type from NamedTypeNode
     * @param name string
     * @param namedTypeNode NamedTypeNode
     * @param directives: additional directives of FieldDefinitionNode
     */
    _namedType(name, namedTypeNode) {
        const field = new model_1.Field(name, namedTypeNode.name.value);
        field.isBuildinType = this._isBuildinType(field.type);
        this._fieldsToProcess.push(field);
        return field;
    }
    /**
     * Mark the object type as entity if '@entity' directive is used
     * @param o ObjectTypeDefinitionNode
     */
    isEntity(o) {
        var _a;
        const entityDirective = (_a = o.directives) === null || _a === void 0 ? void 0 : _a.find((d) => d.name.value === constant_1.ENTITY_DIRECTIVE);
        return !!entityDirective;
    }
    isVariant(o) {
        if (o.directives === undefined) {
            return false;
        }
        return (o.directives.findIndex((d) => d.name.value === constant_1.VARIANT_DIRECTIVE) >= 0);
    }
    isUnique(field) {
        var _a;
        const entityDirective = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.find((d) => d.name.value === constant_1.UNIQUE_DIRECTIVE);
        return !!entityDirective;
    }
    /**
     * Generate a new ObjectType from ObjectTypeDefinitionNode
     * @param o ObjectTypeDefinitionNode
     */
    generateTypeDefination(o) {
        var _a;
        return {
            name: o.name.value,
            fields: this.getFields(o),
            isEntity: this.isEntity(o),
            isVariant: this.isVariant(o),
            description: (_a = o.description) === null || _a === void 0 ? void 0 : _a.value,
            isInterface: o.kind === 'InterfaceTypeDefinition',
            interfaces: o.kind === 'ObjectTypeDefinition' ? this.getInterfaces(o) : [],
        };
    }
    getInterfaces(o) {
        if (!o.interfaces) {
            return [];
        }
        const interfaces = [];
        o.interfaces.map((nameNode) => {
            if (nameNode.kind !== 'NamedType') {
                throw new Error(`Unrecognized interface type: ${JSON.stringify(nameNode, null, 2)}`);
            }
            const name = nameNode.name.value;
            interfaces.push(this._model.lookupInterface(name));
        });
        if (interfaces.length > 1) {
            throw new Error(`A type can implement at most one interface`);
        }
        return interfaces;
    }
    getFields(o) {
        const fields = this._schemaParser
            .getFields(o)
            .map((fieldNode) => {
            var _a;
            const typeNode = fieldNode.type;
            const fieldName = fieldNode.name.value;
            let field;
            if (typeNode.kind === 'NamedType') {
                field = this._namedType(fieldName, typeNode);
            }
            else if (typeNode.kind === 'NonNullType') {
                field =
                    typeNode.type.kind === 'NamedType'
                        ? this._namedType(fieldName, typeNode.type)
                        : this._listType(typeNode.type, fieldName);
                field.nullable = false;
            }
            else if (typeNode.kind === 'ListType') {
                field = this._listType(typeNode, fieldName);
            }
            else {
                throw new Error(`Unrecognized type. ${JSON.stringify(typeNode, null, 2)}`);
            }
            field.description = (_a = fieldNode.description) === null || _a === void 0 ? void 0 : _a.value;
            field.unique = this.isUnique(fieldNode);
            DerivedFrom.addDerivedFromIfy(fieldNode, field);
            return field;
        });
        debug(`Read and parsed fields: ${JSON.stringify(fields, null, 2)}`);
        // ---Temporary Solution---
        // Warthog's BaseModel already has `id` member so we remove id field from object
        // before generation models
        return fields.filter((f) => f.name !== 'id');
    }
    generateInterfaces() {
        this._schemaParser.getInterfaceTypes().map((i) => {
            const astNode = i.astNode;
            if (astNode && this.isEntity(astNode)) {
                this._model.addInterface(this.generateTypeDefination(astNode));
            }
        });
    }
    generateEntities() {
        this._schemaParser
            .getObjectDefinations()
            .filter((o) => this.isEntity(o))
            .map((o) => {
            const objType = this.generateTypeDefination(o);
            this._model.addEntity(objType);
        });
    }
    generateVariants() {
        this._schemaParser
            .getObjectDefinations()
            .filter((o) => this.isVariant(o))
            .map((o) => {
            const objType = this.generateTypeDefination(o);
            this._model.addVariant(objType);
        });
    }
    generateUnions() {
        this._schemaParser.getUnionTypes().map((u) => {
            const types = [];
            u.getTypes().map((s) => types.push(s.name));
            this._model.addUnion(u.name, types);
        });
    }
    generateEnums() {
        this._schemaParser.getEnumTypes().map((e) => this._model.addEnum(e));
    }
    // TODO: queries will be parsed from a top-level directive definition
    // and this part is going to be deprecated
    genereateQueries() {
        const fts = new FTSDirective_1.FTSDirective();
        const visitors = {
            directives: {},
        };
        visitors.directives[FTSDirective_1.FULL_TEXT_SEARCHABLE_DIRECTIVE] = {
            visit: (path) => fts.generate(path, this._model),
        };
        this._schemaParser.dfsTraversal(visitors);
    }
    postProcessFields() {
        while (this._fieldsToProcess) {
            const f = this._fieldsToProcess.pop();
            if (!f)
                return;
            f.modelType = this._model.lookupType(f.type);
        }
    }
    buildWarthogModel() {
        this._model = new model_1.WarthogModel();
        this.generateEnums();
        this.generateInterfaces();
        this.generateVariants();
        this.generateUnions();
        this.generateEntities();
        this.postProcessFields();
        this.genereateQueries();
        DerivedFrom.validateDerivedFields(this._model);
        new RelationshipGenerator_1.RelationshipGenerator(this._model).generate();
        return this._model;
    }
}
exports.WarthogModelBuilder = WarthogModelBuilder;
