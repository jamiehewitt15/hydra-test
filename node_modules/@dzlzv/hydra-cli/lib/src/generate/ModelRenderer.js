"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelRenderer = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const field_context_1 = require("./field-context");
const utils = tslib_1.__importStar(require("./utils"));
const AbstractRenderer_1 = require("./AbstractRenderer");
const debug = debug_1.default('qnode-cli:model-renderer');
class ModelRenderer extends AbstractRenderer_1.AbstractRenderer {
    constructor(model, objType, enumContextProvider, context = {}) {
        super(model, context);
        this.objType = objType;
        this.enumCtxProvider = enumContextProvider;
    }
    withInterfaceProp() {
        return {
            isInterface: this.objType.isInterface,
        };
    }
    withInterfaces() {
        if (utils.hasInterfaces(this.objType) &&
            this.objType.interfaces !== undefined) {
            return {
                interfaces: [utils.withNames(this.objType.interfaces[0].name)],
            };
        }
        return {};
    }
    withSubclasses() {
        if (this.objType.isInterface !== true) {
            return {};
        }
        const subclasses = [];
        this.model
            .getSubclasses(this.objType.name)
            .map((o) => subclasses.push(utils.withNames(o.name)));
        return {
            subclasses,
        };
    }
    withEnums() {
        // we need to have a state to render exports only once
        const referncedEnums = new Set();
        this.objType.fields.map((f) => {
            if (f.isEnum())
                referncedEnums.add(this.model.lookupEnum(f.type));
        });
        const enums = [];
        for (const e of referncedEnums) {
            enums.push(this.enumCtxProvider.withEnum(e));
        }
        return {
            enums,
        };
    }
    withFields() {
        const fields = [];
        utils
            .ownFields(this.objType)
            .map((f) => fields.push(field_context_1.buildFieldContext(f, this.objType)));
        return {
            fields,
        };
    }
    withDescription() {
        return {
            description: this.objType.description || undefined,
        };
    }
    withHasProps() {
        const has = {};
        for (const field of this.objType.fields) {
            let ct = field.columnType();
            if (ct === 'numeric' || ct === 'decimal')
                ct = 'numeric';
            has[ct] = true;
        }
        has.array = this.objType.fields.some((f) => f.isArray());
        has.enum = this.objType.fields.some((f) => f.isEnum());
        has.union = this.objType.fields.some((f) => f.isUnion());
        debug(`ObjectType has: ${JSON.stringify(has, null, 2)}`);
        return {
            has,
        };
    }
    withImportProps() {
        const relatedEntityImports = new Set();
        this.objType.fields
            .filter((f) => f.relation)
            .forEach((f) => {
            var _a;
            const columnType = (_a = f.relation) === null || _a === void 0 ? void 0 : _a.columnType;
            if (!columnType) {
                // should never happen
                throw new Error(`Relation column type for ${f.name} is undefined`);
            }
            relatedEntityImports.add(path.join(`import { ${columnType} } from  '..`, utils.kebabCase(columnType), `${utils.kebabCase(columnType)}.model'`));
        });
        return {
            relatedEntityImports: Array.from(relatedEntityImports.values()),
        };
    }
    withFieldResolvers() {
        const fieldResolvers = [];
        const fieldResolverImports = new Set();
        const entityName = this.objType.name;
        for (const f of this.objType.fields) {
            if (!f.relation)
                continue;
            const returnTypeFunc = f.relation.columnType;
            fieldResolvers.push({
                returnTypeFunc,
                rootArgType: entityName,
                fieldName: f.name,
                rootArgName: 'r',
                returnType: utils.generateResolverReturnType(returnTypeFunc, f.isList),
            });
            fieldResolverImports.add(utils.generateEntityImport(returnTypeFunc));
        }
        const imports = Array.from(fieldResolverImports.values());
        // If there is at least one field resolver then add typeorm to imports
        if (imports.length) {
            imports.push(`import { getConnection } from 'typeorm';`);
        }
        return {
            fieldResolvers,
            fieldResolverImports: imports,
        };
    }
    transform() {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.context), this.withFields()), this.withEnums()), this.withInterfaces()), this.withInterfaceProp()), this.withHasProps()), this.withSubclasses()), this.withDescription()), this.withImportProps()), this.withFieldResolvers()), utils.withNames(this.objType.name));
    }
}
exports.ModelRenderer = ModelRenderer;
