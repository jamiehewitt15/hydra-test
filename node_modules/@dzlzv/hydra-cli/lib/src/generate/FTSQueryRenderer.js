"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FTSQueryRenderer = void 0;
const tslib_1 = require("tslib");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const lodash_1 = require("lodash");
const StringUtils_1 = require("typeorm/util/StringUtils");
const debug = debug_1.default('qnode-cli:model-generator');
class FTSQueryRenderer {
    constructor(context = {}) {
        this._context = {};
        this._context = context;
    }
    generate(mustacheTeplate, query) {
        debug(`Generating query with ${JSON.stringify(query, null, 2)}`);
        const mustacheQuery = this.transform(query);
        return mustache_1.default.render(mustacheTeplate, mustacheQuery);
    }
    transform(query) {
        if (query.clauses.length === 0) {
            throw new Error('A query should contain at least one clause');
        }
        const prefix = this.queryName2prefix(query.name);
        // const entityObjType = this.lookupType(query.fields[0]);
        const entities = [];
        const documents = [];
        const name2doc = {};
        const name2entity = {};
        query.clauses.map((v) => {
            if (!name2doc[v.entity.name]) {
                const table = this.name2table(v.entity.name);
                name2doc[v.entity.name] = {
                    tsvColumn: `${prefix}_tsv`,
                    docColumn: `${prefix}_doc`,
                    index_name: `${prefix}_${table}_idx`,
                    table,
                    fields: [],
                    last: false,
                };
                name2entity[v.entity.name] = this.objectTypeToMustache(v.entity);
            }
            name2doc[v.entity.name].fields.push({
                column: this.name2column(v.field.name),
                weight: 'A',
                last: false,
            });
        });
        Object.entries(name2doc).forEach(([entityName, doc]) => {
            entities.push(name2entity[entityName]);
            doc.fields[doc.fields.length - 1].last = true;
            documents.push(doc);
        });
        documents[documents.length - 1].last = true;
        entities[entities.length - 1].last = true;
        return {
            entities,
            query: {
                viewName: `${prefix}_view`,
                typePrefix: lodash_1.upperFirst(query.name),
                name: query.name,
                language: 'english',
                documents,
                ts: this._context.ts ? this._context.ts : Date.now(),
            },
        };
    }
    objectTypeToMustache(objType) {
        return {
            type: lodash_1.upperFirst(objType.name),
            table: this.name2table(objType.name),
            model: this.name2modelName(objType.name),
            fieldName: this.fieldName(objType.name),
            arrayName: this.arrayName(objType.name),
            last: false,
        };
    }
    // TODO: hmm this really depends on typeorm naming strategy
    name2column(name) {
        return `"${name}"`;
    }
    name2table(name) {
        return StringUtils_1.snakeCase(name);
    }
    queryName2prefix(qName) {
        return StringUtils_1.snakeCase(qName);
    }
    name2modelName(name) {
        return lodash_1.kebabCase(name);
    }
    fieldName(name) {
        return lodash_1.lowerFirst(name);
    }
    arrayName(name) {
        return `${this.fieldName(name)}s`;
    }
}
exports.FTSQueryRenderer = FTSQueryRenderer;
