"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelationshipGenerator = void 0;
const model_1 = require("../model");
const relations_1 = require("../model/relations");
class RelationshipGenerator {
    constructor(model) {
        this.model = model;
        this._relationships = [];
        this.visited = new Set();
    }
    createRelationship(entity, relatedEntity, field, relatedField, type) {
        const rel = {
            entityName: entity.name,
            relatedEntityName: relatedEntity.name,
            field,
            relatedField,
            type,
        };
        this._relationships.push(rel);
        this.visited.add(`${field.name}:${relatedField.name}`);
    }
    listFieldWithDerivedFromDirective(entity, relatedEntity, field) {
        const relatedField = relatedEntity.fields.find((f) => field.derivedFrom && field.derivedFrom.argument === f.name);
        if (!relatedField) {
            throw Error(`Incorrect relationship detected. A field like 'someField: [${entity.name}]' must exists on ${relatedEntity.name}`);
        }
        if (this.visited.has(`${field.name}:${relatedField.name}`)) {
            return false;
        }
        relatedField.isList
            ? this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.MTM)
            : this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.OTM);
        return true;
    }
    listFieldWithoutDerivedFromDirective(entity, relatedEntity, field) {
        const relatedField = relatedEntity.fields.find((f) => f.type === entity.name &&
            f.derivedFrom &&
            f.derivedFrom.argument === field.name);
        if (relatedField === undefined) {
            throw Error(`Incorrect relationship detected A field like 'someField: [${entity.name}] @derivedFrom(${field.name})' must exists on ${relatedEntity.name}`);
        }
        if (this.visited.has(`${field.name}:${relatedField.name}`))
            return false;
        this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.MTM);
        return true;
    }
    fieldWithDerivedFromDirective(entity, relatedEntity, field) {
        const relatedField = relatedEntity.fields.find((f) => {
            var _a;
            return f.type === entity.name &&
                f.name === ((_a = field.derivedFrom) === null || _a === void 0 ? void 0 : _a.argument) &&
                !field.isList &&
                !f.derivedFrom;
        });
        if (relatedField === undefined) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const arg = field.derivedFrom.argument;
            throw Error(`Incorrect relationship! A field like 'someField: ${entity.name} @derivedFrom("${arg}")' should exists on ${relatedEntity.name}`);
        }
        if (this.visited.has(`${field.name}:${relatedField.name}`))
            return false;
        this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.OTO);
        return true;
    }
    fieldWithoutDerivedFromDirective(entity, relatedEntity, field) {
        // Get all the related fields
        const relatedFields = relatedEntity.fields.filter((f) => f.type === entity.name);
        // No fields found build OneToMany relationship
        if (relatedFields.length === 0) {
            const relatedField = relations_1.relations.createAdditionalField(entity, field);
            if (this.visited.has(`${field.name}:${relatedField.name}`))
                return false;
            this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.OTM);
            return true;
        }
        const relatedField = relatedFields.find((f) => { var _a; return f.derivedFrom !== undefined && ((_a = f.derivedFrom) === null || _a === void 0 ? void 0 : _a.argument) === field.name; });
        if (relatedField === undefined) {
            const relatedField = relations_1.relations.createAdditionalField(entity, field);
            if (this.visited.has(`${field.name}:${relatedField.name}`))
                return false;
            this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.OTM);
            return true;
        }
        if (this.visited.has(`${field.name}:${relatedField.name}`))
            return false;
        relatedField.isList
            ? this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.OTM)
            : this.createRelationship(entity, relatedEntity, field, relatedField, model_1.RelationType.OTO);
        return true;
    }
    // Adds 'relation' property to fields
    _addRelationPropertyFields() {
        for (const rel of this._relationships) {
            switch (rel.type) {
                case 'oto':
                    relations_1.relations.addOne2One(rel);
                    break;
                case 'otm':
                    relations_1.relations.addOne2Many(rel);
                    break;
                case 'mtm':
                    relations_1.relations.addMany2Many(rel);
                    break;
                default:
                    throw Error(`Unknown relation type: ${rel.type}`);
            }
        }
    }
    _addAdditionalFieldsForOneToManyRelationship() {
        // Add missing fields to entities
        for (const r of this._relationships) {
            if (r.type !== 'otm')
                continue;
            const entity = this.model.lookupEntity(r.relatedEntityName);
            const field = entity.fields.find((f) => f.name === r.relatedField.name);
            if (field === undefined)
                entity.fields.push(r.relatedField);
        }
    }
    buildRelationships() {
        const entityNames = this.model.entities.map((t) => t.name);
        for (const entity of this.model.entities) {
            for (const field of entity.fields) {
                // No relation continue
                if (!entityNames.includes(field.type))
                    continue;
                const relatedEntity = this.model.lookupEntity(field.type);
                const { isList, derivedFrom } = field;
                if (isList && derivedFrom === undefined) {
                    if (!this.listFieldWithoutDerivedFromDirective(entity, relatedEntity, field))
                        continue;
                }
                if (isList && derivedFrom !== undefined) {
                    if (!this.listFieldWithDerivedFromDirective(entity, relatedEntity, field))
                        continue;
                }
                if (!isList && derivedFrom === undefined) {
                    if (!this.fieldWithoutDerivedFromDirective(entity, relatedEntity, field))
                        continue;
                }
                if (!isList && derivedFrom !== undefined) {
                    if (!this.fieldWithDerivedFromDirective(entity, relatedEntity, field))
                        continue;
                }
            }
        }
    }
    generate() {
        this.buildRelationships();
        this._addRelationPropertyFields();
        this._addAdditionalFieldsForOneToManyRelationship();
    }
}
exports.RelationshipGenerator = RelationshipGenerator;
