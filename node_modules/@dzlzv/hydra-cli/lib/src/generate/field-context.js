"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withTransformer = exports.withRelation = exports.withImport = exports.withDerivedNames = exports.withArrayCustomFieldConfig = exports.withTsTypeAndDecorator = exports.withUnique = exports.withDescription = exports.withRequired = exports.withFieldTypeGuardProps = exports.buildFieldContext = exports.TYPE_FIELDS = void 0;
const tslib_1 = require("tslib");
const util = tslib_1.__importStar(require("./utils"));
const enum_context_1 = require("./enum-context");
exports.TYPE_FIELDS = {
    bool: {
        decorator: 'BooleanField',
        tsType: 'boolean',
    },
    date: {
        decorator: 'DateTimeField',
        tsType: 'Date',
    },
    int: {
        decorator: 'IntField',
        tsType: 'number',
    },
    float: {
        decorator: 'FloatField',
        tsType: 'number',
    },
    json: {
        decorator: 'JSONField',
        tsType: 'JsonObject',
    },
    otm: {
        decorator: 'OneToMany',
        tsType: '---',
    },
    mto: {
        decorator: 'ManyToOne',
        tsType: '---',
    },
    mtm: {
        decorator: 'ManyToMany',
        tsType: '---',
    },
    string: {
        decorator: 'StringField',
        tsType: 'string',
    },
    numeric: {
        decorator: 'NumericField',
        tsType: 'BN',
    },
    decimal: {
        decorator: 'NumericField',
        tsType: 'BN',
    },
    oto: {
        decorator: 'OneToOne',
        tsType: '---',
    },
    array: {
        decorator: 'ArrayField',
        tsType: '',
    },
    bytes: {
        decorator: 'BytesField',
        tsType: 'Buffer',
    },
};
const graphQLFieldTypes = {
    bool: 'boolean',
    int: 'integer',
    string: 'string',
    float: 'float',
    date: 'date',
    numeric: 'numeric',
    decimal: 'numeric',
};
function buildFieldContext(f, entity) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, withFieldTypeGuardProps(f)), withRequired(f)), withUnique(f)), withRelation(f)), withArrayCustomFieldConfig(f)), withTsTypeAndDecorator(f)), withDerivedNames(f, entity)), withDescription(f)), withTransformer(f));
}
exports.buildFieldContext = buildFieldContext;
function withFieldTypeGuardProps(f) {
    const is = {};
    is.array = f.isArray();
    is.scalar = f.isScalar();
    is.enum = f.isEnum();
    is.union = f.isUnion();
    ['mto', 'oto', 'otm', 'mtm'].map((s) => { var _a; return (is[s] = ((_a = f.relation) === null || _a === void 0 ? void 0 : _a.type) === s); });
    return {
        is: is,
    };
}
exports.withFieldTypeGuardProps = withFieldTypeGuardProps;
function withRequired(f) {
    return {
        required: !f.nullable,
    };
}
exports.withRequired = withRequired;
function withDescription(f) {
    return {
        description: f.description,
    };
}
exports.withDescription = withDescription;
function withUnique(f) {
    return {
        unique: f.unique,
    };
}
exports.withUnique = withUnique;
function withTsTypeAndDecorator(f) {
    const fieldType = f.columnType();
    if (exports.TYPE_FIELDS[fieldType]) {
        return Object.assign({}, exports.TYPE_FIELDS[fieldType]);
    }
    return {
        tsType: f.type,
    };
}
exports.withTsTypeAndDecorator = withTsTypeAndDecorator;
function withArrayCustomFieldConfig(f) {
    if (!f.isArray()) {
        return {};
    }
    const type = f.columnType();
    const apiType = graphQLFieldTypes[type];
    let dbType = apiType;
    if (dbType === 'string') {
        dbType = 'text'; // postgres doesnt have 'string'
    }
    else if (dbType === 'float') {
        dbType = 'decimal'; // postgres doesnt have 'float'
    }
    return {
        dbType,
        apiType,
    };
}
exports.withArrayCustomFieldConfig = withArrayCustomFieldConfig;
function withDerivedNames(f, entity) {
    return Object.assign(Object.assign({}, util.names(f.name)), { relFieldName: util.camelCase(entity.name), relFieldNamePlural: util.camelPlural(entity.name) });
}
exports.withDerivedNames = withDerivedNames;
function withImport(f) {
    if (!f.isEnum()) {
        return {};
    }
    return Object.assign({ className: f.type }, enum_context_1.withRelativePathForEnum());
}
exports.withImport = withImport;
function withRelation(f) {
    return {
        relation: f.relation,
    };
}
exports.withRelation = withRelation;
function withTransformer(f) {
    if (exports.TYPE_FIELDS[f.columnType()] &&
        exports.TYPE_FIELDS[f.columnType()].tsType === 'BN') {
        return {
            transformer: `{
        to: (entityValue: BN) => (entityValue !== undefined) ? entityValue.toString(10) : null,
        from: (dbValue: string) => dbValue !== undefined && dbValue !== null && dbValue.length > 0 ? new BN(dbValue, 10): undefined,
      }`,
        };
    }
    return {};
}
exports.withTransformer = withTransformer;
