"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourcesGenerator = exports.INTERFACES_FOLDER = exports.VARIANTS_FOLDER = exports.ENUMS_FOLDER = exports.QUERIES_FOLDER = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const utils_1 = require("../utils/utils");
const debug_1 = tslib_1.__importDefault(require("debug"));
const FTSQueryRenderer_1 = require("./FTSQueryRenderer");
const ModelRenderer_1 = require("./ModelRenderer");
const EnumRenderer_1 = require("./EnumRenderer");
const utils_2 = require("./utils");
const ConfigProvider_1 = require("./ConfigProvider");
const EnumContextProvider_1 = require("./EnumContextProvider");
const VariantsRenderer_1 = require("./VariantsRenderer");
const debug = debug_1.default('qnode-cli:sources-generator');
exports.QUERIES_FOLDER = 'queries';
exports.ENUMS_FOLDER = 'enums';
exports.VARIANTS_FOLDER = 'variants';
exports.INTERFACES_FOLDER = 'interfaces';
class SourcesGenerator {
    constructor(model) {
        this.config = new ConfigProvider_1.ConfigProvider();
        this.model = model;
    }
    generate() {
        this.generateEnums();
        this.generateVariants();
        this.generateModels();
        this.generateQueries();
    }
    generateModels() {
        utils_1.createDir(path.resolve(process.cwd(), 'src/modules'), false, true);
        const enumContextProvider = new EnumContextProvider_1.EnumContextProvider();
        const typesAndInterfaces = [
            ...this.model.interfaces,
            ...this.model.entities,
        ];
        typesAndInterfaces.map((objType) => {
            const context = this.config.withGeneratedFolderRelPath(objType.name);
            const modelRenderer = new ModelRenderer_1.ModelRenderer(this.model, objType, enumContextProvider, context);
            const destFolder = this.config.getDestFolder(objType.name);
            utils_1.createDir(path.resolve(process.cwd(), destFolder), false, true);
            const tempateFile = {
                model: 'entities/model.ts.mst',
                resolver: objType.isInterface
                    ? 'interfaces/resolver.ts.mst'
                    : 'entities/resolver.ts.mst',
                service: objType.isInterface
                    ? 'interfaces/service.ts.mst'
                    : 'entities/service.ts.mst',
            };
            ['model', 'resolver', 'service'].map((template) => {
                const rendered = modelRenderer.render(this.readTemplate(tempateFile[template]));
                const destPath = path.join(destFolder, `${utils_2.kebabCase(objType.name)}.${template}.ts`);
                this.writeFile(destPath, rendered);
            });
        });
    }
    generateQueries() {
        if (!this.model) {
            throw new Error('Warthog model is undefined');
        }
        // create migrations dir if not exists
        const migrationsDir = this.config.getMigrationsFolder();
        fs.ensureDirSync(path.resolve(process.cwd(), migrationsDir));
        // create dir if the textsearch module
        const ftsDir = this.config.getDestFolder(exports.QUERIES_FOLDER);
        fs.ensureDirSync(path.resolve(process.cwd(), ftsDir));
        const queryRenderer = new FTSQueryRenderer_1.FTSQueryRenderer();
        this.model.ftsQueries.map((query) => {
            const tempateFile = (name) => this.readTemplate(`textsearch/${name}.ts.mst`);
            const destPath = {
                migration: path.join(migrationsDir, `${query.name}.migration.ts`),
                resolver: path.join(ftsDir, `${query.name}.resolver.ts`),
                service: path.join(ftsDir, `${query.name}.service.ts`),
            };
            ['migration', 'resolver', 'service'].map((name) => {
                const rendered = queryRenderer.generate(tempateFile(name), query);
                debug(`Writing ${query.name} ${name} to ${destPath[name]}`);
                this.writeFile(destPath[name], rendered);
            });
        });
    }
    generateVariants() {
        if (!this.model.unions) {
            return;
        }
        const unionDir = this.config.getDestFolder(exports.VARIANTS_FOLDER);
        utils_1.createDir(path.resolve(process.cwd(), unionDir), false, true);
        const renderer = new VariantsRenderer_1.VariantsRenderer(this.model);
        const template = this.readTemplate('variants/variants.mst');
        this.writeFile(path.join(unionDir, 'variants.model.ts'), renderer.render(template));
    }
    generateEnums() {
        if (!this.model.enums) {
            return;
        }
        const enumsDir = this.config.getDestFolder(exports.ENUMS_FOLDER);
        utils_1.createDir(path.resolve(process.cwd(), enumsDir), false, true);
        const enumRenderer = new EnumRenderer_1.EnumRenderer(this.model);
        const rendered = enumRenderer.render(this.readTemplate('entities/enums.ts.mst'));
        this.writeFile(path.join(enumsDir, `enums.ts`), rendered);
    }
    /**
     *
     * @param template relative path to a template from the templates folder, e.g. 'db-helper.mst'
     * @param destPath relative path to the `generated/graphql-server' folder, e.g. 'src/index.ts'
     * @param render function which transforms the template contents
     */
    renderAndWrite(template, destPath, render) {
        const templateData = fs.readFileSync(utils_1.getTemplatePath(template), 'utf-8');
        debug(`Source: ${utils_1.getTemplatePath(template)}`);
        const rendered = render(templateData);
        debug(`Transformed: ${rendered}`);
        const destFullPath = path.resolve(process.cwd(), destPath);
        debug(`Writing to: ${destFullPath}`);
        utils_1.createFile(destFullPath, rendered, true);
    }
    readTemplate(relPath) {
        debug(`Reading template: ${relPath}`);
        return fs.readFileSync(utils_1.getTemplatePath(relPath), 'utf-8');
    }
    writeFile(destPath, data) {
        const destFullPath = path.resolve(process.cwd(), destPath);
        debug(`Writing to: ${destFullPath}`);
        utils_1.createFile(destFullPath, data, true);
    }
}
exports.SourcesGenerator = SourcesGenerator;
