"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WarthogModel = exports.ModelType = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const validate_1 = require("./validate");
const ScalarTypes_1 = require("./ScalarTypes");
const debug = debug_1.default('qnode-cli:model');
var ModelType;
(function (ModelType) {
    ModelType[ModelType["ENUM"] = 0] = "ENUM";
    ModelType[ModelType["VARIANT"] = 1] = "VARIANT";
    ModelType[ModelType["ENTITY"] = 2] = "ENTITY";
    ModelType[ModelType["UNION"] = 3] = "UNION";
    ModelType[ModelType["INTERFACE"] = 4] = "INTERFACE";
    ModelType[ModelType["SCALAR"] = 5] = "SCALAR";
})(ModelType = exports.ModelType || (exports.ModelType = {}));
class WarthogModel {
    constructor() {
        this._enums = [];
        this._interfaces = [];
        this._variants = [];
        this._unions = [];
        this._name2query = {};
        this._name2type = {};
        this._entities = [];
        this._ftsQueries = [];
    }
    addUnion(name, typeNames) {
        const types = [];
        typeNames.map((t) => types.push(this.lookupVariant(t)));
        this._unions.push({
            name,
            types,
        });
    }
    addVariant(type) {
        if (!type.isVariant) {
            debug(`${type.name} is not an Entity`);
            return;
        }
        if (type.isEntity) {
            throw new Error('An entity cannot be a variant');
        }
        type.fields.forEach((f) => {
            validate_1.validateVariantField(f);
        });
        this._variants.push(type);
    }
    addEntity(type) {
        if (!type.isEntity) {
            debug(`${type.name} is not an Entity`);
            return;
        }
        this._entities.push(type);
        this._name2type[type.name] = type;
    }
    addFTSQuery(query) {
        if (!this._name2query[query.name]) {
            this._name2query[query.name] = query;
        }
        this._ftsQueries.push(query);
    }
    addInterface(_interface) {
        this._interfaces.push(_interface);
    }
    addEnum(_enum) {
        this._enums.push(_enum);
    }
    /**
     * Add emply full text search query with the given name
     *
     * @param name query name to be added
     */
    addEmptyFTSQuery(name) {
        const query = {
            name,
            clauses: [],
        };
        this.addFTSQuery(query);
        return query;
    }
    _addQueryClause(name, f, t) {
        let q = this._name2query[name];
        if (!q) {
            q = this.addEmptyFTSQuery(name);
        }
        q.clauses.push({
            entity: t,
            field: f,
        });
    }
    /**
     * Add text search field to the named FTS query
     *
     * @param queryName fulltext query name
     * @param fieldName name of the field to be added to the query
     * @param typeName  objectType which defined that field
     */
    addQueryClause(queryName, fieldName, typeName) {
        const field = this.lookupField(typeName, fieldName);
        const objType = this.lookupEntity(typeName);
        this._addQueryClause(queryName, field, objType);
    }
    get entities() {
        return this._entities;
    }
    get ftsQueries() {
        return this._ftsQueries;
    }
    get enums() {
        return this._enums;
    }
    get interfaces() {
        return this._interfaces;
    }
    get variants() {
        return this._variants;
    }
    get unions() {
        return this._unions;
    }
    /**
     * Lookup ObjectType by it's name (as defined in the schema file)
     *
     * @param name ObjectTypeName as defined in the schema
     */
    lookupEntity(name) {
        if (!this._name2type[name]) {
            throw new Error(`Entity ${name} is undefined. Make sure the type definition is decorated with @entity.`);
        }
        return this._name2type[name];
    }
    lookupUnion(name) {
        const u = this._unions.find((u) => u.name === name);
        if (!u)
            throw new Error(`Cannot find union type with name ${name}`);
        return u;
    }
    lookupEnum(name) {
        const e = this._enums.find((e) => e.name === name);
        if (!e)
            throw new Error(`Cannot find enum with name ${name}`);
        return e;
    }
    lookupVariant(name) {
        const e = this._variants.find((e) => e.name === name);
        if (!e)
            throw new Error(`Variant ${name} is undefined. Make sure the type definition is decorated with @variant.`);
        return e;
    }
    lookupInterface(name) {
        const e = this._interfaces.find((e) => e.name === name);
        if (!e)
            throw new Error(`Cannot find interface with name ${name}`);
        return e;
    }
    lookupQuery(queryName) {
        if (!this._name2query) {
            throw new Error(`No query with name ${queryName} found`);
        }
        return this._name2query[queryName];
    }
    /**
     * Get subclasses of a given interface
     *
     * @param interfaceName Name of the interface
     */
    getSubclasses(interfaceName) {
        return this._entities.filter((t) => t.interfaces &&
            t.interfaces.length > 0 &&
            t.interfaces[0].name === interfaceName);
    }
    /**
     * Lookup Warthog's Field model object by it's ObjectType and name
     *
     * @param objTypeName Type name with the given field defined
     * @param name the name of the field
     */
    lookupField(objTypeName, name) {
        const objType = this.lookupEntity(objTypeName);
        const field = objType.fields.find((f) => f.name === name);
        if (!field) {
            throw new Error(`No field ${name} is found for object type ${objTypeName}`);
        }
        return field;
    }
    addField(entity, field) {
        const objType = this.lookupEntity(entity);
        objType.fields.push(field);
    }
    lookupType(name) {
        if (name in ScalarTypes_1.availableTypes) {
            return ModelType.SCALAR;
        }
        if (this._name2type[name]) {
            return ModelType.ENTITY;
        }
        if (this._interfaces.find((i) => i.name === name)) {
            return ModelType.INTERFACE;
        }
        if (this._variants.find((v) => v.name === name)) {
            return ModelType.VARIANT;
        }
        if (this._unions.find((u) => u.name === name)) {
            return ModelType.UNION;
        }
        if (this._enums.find((e) => e.name === name)) {
            return ModelType.ENUM;
        }
        throw new Error(`Type ${name} is undefined`);
    }
}
exports.WarthogModel = WarthogModel;
