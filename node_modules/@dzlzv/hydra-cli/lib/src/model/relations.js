"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.relations = void 0;
const _1 = require(".");
const utils_1 = require("../generate/utils");
function addMany2Many(rel) {
    const { field, relatedField, entityName, relatedEntityName } = rel;
    rel.field.relation = _1.makeRelation('mtm', field.type, relatedField.name, field.nullable);
    rel.field.relation.joinTable = {
        tableName: utils_1.generateJoinTableName(entityName, relatedEntityName),
        joinColumn: utils_1.generateJoinColumnName(entityName),
        inverseJoinColumn: utils_1.generateJoinColumnName(relatedEntityName),
    };
    rel.relatedField.relation = _1.makeRelation('mtm', relatedField.type, field.name, relatedField.nullable);
}
function addOne2Many(rel) {
    const { field, relatedField } = rel;
    rel.field.relation = _1.makeRelation('mto', field.type, relatedField.name, field.nullable);
    rel.relatedField.relation = _1.makeRelation('otm', relatedField.type, field.name, relatedField.nullable);
}
function addOne2One(rel) {
    const { field, relatedField } = rel;
    rel.field.relation = _1.makeRelation('oto', field.type, relatedField.name, field.nullable);
    rel.relatedField.relation = _1.makeRelation('oto', relatedField.type, field.name, relatedField.nullable);
    // Decide to hold relationship on which side, joincolumn is the side that relation
    // will live
    if (rel.field.derivedFrom) {
        rel.relatedField.relation.joinColumn = true;
    }
    else {
        rel.field.relation.joinColumn = true;
    }
}
// Typeorm requires to have ManyToOne field on the related object if the relation is OneToMany
function createAdditionalField(entity, field) {
    const f = new _1.Field(entity.name.toLowerCase() + field.name, entity.name, true, false, true);
    f.description = 'Addtional field required to build OneToMany relationship';
    return f;
}
exports.relations = {
    addMany2Many,
    addOne2Many,
    addOne2One,
    createAdditionalField,
};
