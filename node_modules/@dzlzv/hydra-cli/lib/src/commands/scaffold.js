"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const utils = tslib_1.__importStar(require("./../utils/utils"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const utils_1 = require("../utils/utils");
const Mustache = require("mustache");
const dotenv = require("dotenv");
const execa = require("execa");
const glob = require("glob");
const DEFAULT_WS_API_ENDPOINT = 'wss://kusama-rpc.polkadot.io/';
const KUSAMA_INDEXER = 'https://indexer-kusama.joystream.app/graphql';
class Scaffold extends command_1.Command {
    async run() {
        const { flags } = this.parse(Scaffold);
        await fs.writeFile(path.join(process.cwd(), '.env'), flags.projectName
            ? await this.dotenvFromFlags(flags)
            : await this.promptDotEnv());
        dotenv.config();
        this.log('Your settings have been saved to .env, feel free to edit');
        cli_ux_1.default.action.start('Scaffolding');
        if (flags.mappings) {
            await this.setupMappings();
        }
        await this.setupNodeProject();
        await this.setupDocker();
        cli_ux_1.default.action.stop();
    }
    async dotenvFromFlags(flags) {
        const template = await fs.readFile(utils_1.getTemplatePath('scaffold/.env'), 'utf-8');
        return Mustache.render(template, Object.assign(Object.assign({}, flags), { dbName: flags.projectName }));
    }
    async promptDotEnv() {
        let ctx = {};
        const projectName = (await cli_ux_1.default.prompt('Enter your project name', {
            required: true,
        }));
        ctx = Object.assign(Object.assign({}, ctx), { projectName });
        ctx = Object.assign(Object.assign({}, ctx), (await this.promptIndexerEnvs(ctx)));
        ctx = Object.assign(Object.assign({}, ctx), (await this.promptProcessorEnvs(ctx)));
        const dbName = (await cli_ux_1.default.prompt('Database name', {
            default: projectName,
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbName });
        const dbHost = (await cli_ux_1.default.prompt('Database host', {
            default: 'localhost',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbHost });
        const dbPort = (await cli_ux_1.default.prompt('Database port', {
            default: '5432',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbPort });
        const dbUser = (await cli_ux_1.default.prompt('Database user', {
            default: 'postgres',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbUser });
        const dbPassword = (await cli_ux_1.default.prompt('Database user password', {
            type: 'mask',
            default: 'postgres',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbPassword });
        const template = await fs.readFile(utils_1.getTemplatePath('scaffold/.env'), 'utf-8');
        return Mustache.render(template, ctx);
    }
    async promptProcessorEnvs(ctx) {
        const proceed = await cli_ux_1.default.confirm('Are you going to run an mappings processor?');
        if (!proceed) {
            return ctx;
        }
        const indexerUrl = (await cli_ux_1.default.prompt('Provide an indexer GraphQL API endpoint to source events from', {
            default: KUSAMA_INDEXER,
        }));
        ctx = Object.assign(Object.assign({}, ctx), { indexerUrl });
        const appPort = (await cli_ux_1.default.prompt('Processor GraphQL server port', {
            default: '4000',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { appPort });
        return ctx;
    }
    async promptIndexerEnvs(ctx) {
        const proceed = await cli_ux_1.default.confirm('Are you going to run an indexer?');
        if (!proceed) {
            return ctx;
        }
        ctx = Object.assign({}, ctx);
        const wsProviderUrl = (await cli_ux_1.default.prompt('Substrate WS provider endpoint', {
            default: DEFAULT_WS_API_ENDPOINT,
        }));
        ctx = Object.assign(Object.assign({}, ctx), { wsProviderUrl });
        const blockHeight = (await cli_ux_1.default.prompt('What is the block height the indexer should start from?', {
            default: '0',
        }));
        if (isNaN(parseInt(blockHeight))) {
            throw new Error('Starting block height must be an integer');
        }
        ctx = Object.assign(Object.assign({}, ctx), { blockHeight });
        const redisUri = (await cli_ux_1.default.prompt('Please provide a Redis instance connection string', {
            default: 'redis://localhost:6379/0',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { redisUri });
        ctx = await this.promptCustomTypes(ctx);
        return ctx;
    }
    async promptCustomTypes(ctx) {
        const proceed = await cli_ux_1.default.confirm('Are there any non-standard types or modules in the substrate runtime?');
        if (!proceed) {
            return ctx;
        }
        const typesJSON = (await cli_ux_1.default.prompt('Please provide the localtion of the type definitions JSON, relative to ./generated/indexer', { default: '../../typedefs.json' }));
        return Object.assign(Object.assign({}, ctx), { typesJSON });
    }
    // For now, we simply copy the hardcoded templates from the mappings dir
    async setupMappings() {
        await utils.copyTemplateToCWD('scaffold/schema.graphql', 'schema.graphql');
        await fs.ensureDir('mappings');
        const mappingFiles = glob.sync(path.join(__dirname, '..', '/templates/scaffold/mappings/**/*.ts'));
        // TODO: make this generic and move to utils
        for (const f of mappingFiles) {
            const pathParts = f.split(path.sep);
            // remove the trailing parts of the path up to ./scaffold
            let topDir = pathParts.shift();
            while (topDir !== 'scaffold') {
                topDir = pathParts.shift();
            }
            const targetDir = path.join(...pathParts);
            await utils.copyTemplateToCWD(path.join('scaffold', targetDir), targetDir);
        }
    }
    async setupDocker() {
        await fs.ensureDir('docker');
        await utils.copyTemplateToCWD('scaffold/docker-compose.yml', 'docker-compose.yml');
        await utils.copyTemplateToCWD('scaffold/docker/Dockerfile.hydra', path.join('docker', 'Dockerfile.hydra'));
        await utils.copyTemplateToCWD('scaffold/.dockerignore', '.dockerignore');
    }
    async setupNodeProject() {
        const template = await fs.readFile(utils_1.getTemplatePath('scaffold/package.json'), 'utf-8');
        await fs.writeFile(path.join(process.cwd(), 'package.json'), Mustache.render(template, {
            projectName: process.env.PROJECT_NAME,
            hydraVersion: process.env.HYDRA_CLI_VERSION ||
                utils.resolvePackageVersion('@dzlzv/hydra-cli'),
            hydraCommonVersion: utils.resolvePackageVersion('@dzlzv/hydra-common'),
            hydraDbUtilsVersion: utils.resolvePackageVersion('@dzlzv/hydra-db-utils'),
            hydraProcessorVersion: utils.resolvePackageVersion('@dzlzv/hydra-processor'),
        }));
        await execa('yarn', ['install']);
    }
}
exports.default = Scaffold;
Scaffold.description = `Starter kit: generates a directory layout and a sample schema file`;
Scaffold.flags = {
    projectName: command_1.flags.string({ char: 'n', description: 'Project name' }),
    wsProviderUrl: command_1.flags.string({
        char: 'w',
        description: 'Substrate WS provider endpoint',
        default: DEFAULT_WS_API_ENDPOINT,
    }),
    indexerUrl: command_1.flags.string({
        char: 'i',
        description: 'Hydra Indexer endpoint',
        default: KUSAMA_INDEXER,
    }),
    // pass --no-mappings to skip default mappings and schema
    mappings: command_1.flags.boolean({
        char: 'm',
        allowNo: true,
        description: 'Create schema and mappings',
        default: true,
    }),
    blockHeight: command_1.flags.string({
        char: 'b',
        description: 'Start block height',
        default: '0',
    }),
    dbHost: command_1.flags.string({
        char: 'h',
        description: 'Database host',
        default: 'localhost',
    }),
    dbPort: command_1.flags.string({
        char: 'p',
        description: 'Database port',
        default: '5432',
    }),
    dbUser: command_1.flags.string({
        char: 'u',
        description: 'Database user',
        default: 'postgres',
    }),
    dbPassword: command_1.flags.string({
        char: 'x',
        description: 'Database user password',
        default: 'postgres',
    }),
    appPort: command_1.flags.string({
        char: 'a',
        description: 'GraphQL server port',
        default: '4000',
    }),
};
