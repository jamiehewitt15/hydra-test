"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const dotenv = tslib_1.__importStar(require("dotenv"));
const cli_1 = require("warthog/dist/cli/cli");
const WarthogModelBuilder_1 = require("../parse/WarthogModelBuilder");
const utils_1 = require("../utils/utils");
const debug_1 = tslib_1.__importDefault(require("debug"));
const SourcesGenerator_1 = require("../generate/SourcesGenerator");
const execa = require("execa");
const Listr = require("listr");
const FALLBACK_WARTHOG_LIB = 'https://github.com/metmirr/warthog/releases/download/v2.19/warthog-v2.19.tgz';
const debug = debug_1.default('qnode-cli:warthog-wrapper');
class WarthogWrapper {
    constructor(flags, prod = true) {
        this.flags = flags;
        this.prod = prod;
        this.schemaResolvedPath = path.resolve(process.cwd(), this.flags.schema);
        if (!fs.existsSync(this.schemaResolvedPath)) {
            throw new Error(`Cannot open the schema file ${this.schemaResolvedPath}. Check if it exists.`);
        }
    }
    async run() {
        const skipIfNoDeps = () => {
            if (this.flags.install !== true) {
                return 'Skipping: dependencies are not installed';
            }
        };
        const skipSchema = () => {
            if (this.flags.install === true && this.flags.createDb === true) {
                return false;
            }
            return `Skipping. Create the database and run the migrations with yarn db:prepare and yarn db:migrate`;
        };
        // Order of calling functions is important!!!
        debug(`Passed flags: ${JSON.stringify(this.flags, null, 2)}`);
        const tasks = new Listr([
            {
                title: 'Set up a new Warthog project',
                task: async () => {
                    await this.newProject();
                },
            },
            {
                title: 'Prepare project files',
                task: () => {
                    this.prepareProjectFiles();
                },
            },
            {
                title: 'Install dependencies',
                skip: skipIfNoDeps,
                task: async () => {
                    await this.installDependecies();
                },
            },
            {
                title: 'Generate server sources',
                skip: skipIfNoDeps,
                task: () => {
                    this.generateWarthogSources();
                },
            },
            {
                title: 'Warthog codegen',
                skip: skipIfNoDeps,
                task: async () => {
                    await this.codegen();
                },
            },
            {
                title: 'Create DB',
                skip: skipSchema,
                task: async () => {
                    await this.createDB();
                },
            },
            {
                title: 'Create DB schema',
                skip: skipSchema,
                task: async () => {
                    await this.syncSchema();
                },
            },
            {
                title: 'Run DB migrations',
                skip: skipSchema,
                task: async () => {
                    await this.runMigrations();
                },
            },
        ]);
        await tasks.run();
    }
    async generateDB() {
        const tasks = new Listr([
            {
                title: 'Create database',
                task: async () => {
                    if (!process.env.DB_NAME) {
                        throw new Error('DB_NAME env variable is not set, check that .env file exists');
                    }
                    await this.createDB();
                },
            },
            {
                title: 'Sync Schema',
                task: async () => {
                    await this.syncSchema();
                },
            },
            {
                title: 'Run migrations',
                task: async () => {
                    await this.runMigrations();
                },
            },
        ]);
        await tasks.run();
    }
    async newProject(projectName = 'query_node') {
        const consoleFn = console.log;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        console.log = () => { };
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        await cli_1.run(['new', `${projectName}`]);
        console.log = consoleFn;
        // Override warthog's index.ts file for custom naming strategy
        fs.copyFileSync(utils_1.getTemplatePath('graphql-server/graphql-server.index.mst'), path.resolve(process.cwd(), 'src/index.ts'));
        fs.copyFileSync(utils_1.getTemplatePath(`graphql-server/graphql-server.tsconfig.json`), path.resolve(process.cwd(), 'tsconfig.json'));
        await this.updateDotenv();
    }
    prepareProjectFiles() {
        if (!fs.existsSync('package.json')) {
            throw new Error('Could not find package.json file in the current working directory');
        }
        const pkgFile = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        pkgFile.scripts['db:sync'] =
            'SYNC=true WARTHOG_DB_SYNCHRONIZE=true ts-node --type-check src/index.ts';
        // Fix ts-node-dev error
        pkgFile.scripts['start:dev'] = 'ts-node --type-check src/index.ts';
        // Node does not run the compiled code, so we use ts-node in production...
        pkgFile.scripts['start:prod'] =
            'WARTHOG_ENV=production yarn dotenv:generate && ts-node src/index.ts';
        pkgFile.dependencies.warthog = this.getWarthogDependency();
        fs.writeFileSync('package.json', JSON.stringify(pkgFile, null, 2));
    }
    async installDependecies() {
        debug('Installing the dependencies');
        await execa('yarn', ['add', 'lodash']); // add lodash dep
        await execa('yarn', ['add', '-D', 'typeorm']); // dev dependency
        await execa('yarn', ['install']);
    }
    async createDB() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        await cli_1.run(['db:create']);
    }
    getWarthogDependency() {
        /* eslint-disable */
        const warthogPackageJson = require('warthog/package.json');
        debug(`Warthog package json: ${JSON.stringify(warthogPackageJson, null, 2)}`);
        // if there is a special 'hydra' property, use it as depenency, otherwise use hardcoded fallback
        return (warthogPackageJson.hydra || FALLBACK_WARTHOG_LIB);
    }
    /**
     * Generate the warthog source files:
     *   - model/resolver/service for entities
     *   - Fulltext search queries (migration/resolver/service)
     */
    generateWarthogSources() {
        const modelBuilder = new WarthogModelBuilder_1.WarthogModelBuilder(this.schemaResolvedPath);
        const model = modelBuilder.buildWarthogModel();
        const sourcesGenerator = new SourcesGenerator_1.SourcesGenerator(model);
        sourcesGenerator.generate();
    }
    async codegen() {
        await execa('yarn', ['warthog', 'codegen']);
        if (this.prod)
            await execa('yarn', ['dotenv:generate']);
    }
    async syncSchema() {
        await execa('yarn', ['db:sync']);
    }
    async runMigrations() {
        debug('performing migrations');
        await execa('yarn', ['db:migrate']);
    }
    async updateDotenv() {
        // copy dotnenvi env.yml file
        debug('Creating graphql-server/env.yml');
        await fs.copyFile(utils_1.getTemplatePath('graphql-server/warthog.env.yml'), path.resolve(process.cwd(), 'env.yml'));
        const envConfig = dotenv.parse(fs.readFileSync('.env'));
        // Override DB_NAME, PORT, ...
        envConfig['WARTHOG_DB_DATABASE'] =
            process.env.DB_NAME || envConfig['WARTHOG_DB_DATABASE'];
        envConfig['WARTHOG_DB_USERNAME'] =
            process.env.DB_USER || envConfig['WARTHOG_DB_USERNAME'];
        envConfig['WARTHOG_DB_PASSWORD'] =
            process.env.DB_PASS || envConfig['WARTHOG_DB_PASSWORD'];
        envConfig['WARTHOG_DB_HOST'] =
            process.env.DB_HOST || envConfig['WARTHOG_DB_HOST'];
        envConfig['WARTHOG_DB_PORT'] =
            process.env.DB_PORT || envConfig['WARTHOG_DB_PORT'];
        envConfig['WARTHOG_APP_PORT'] =
            process.env.GRAPHQL_SERVER_PORT || envConfig['WARTHOG_APP_PORT'];
        envConfig['WARTHOG_APP_HOST'] =
            process.env.GRAPHQL_SERVER_HOST || envConfig['WARTHOG_APP_HOST'];
        const newEnvConfig = Object.keys(envConfig)
            .map((key) => `${key}=${envConfig[key]}`)
            .join('\n');
        await fs.writeFile('.env', newEnvConfig);
    }
}
exports.default = WarthogWrapper;
