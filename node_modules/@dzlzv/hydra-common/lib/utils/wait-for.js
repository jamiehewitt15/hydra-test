"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryWithTimeout = exports.retry = exports.withTimeout = exports.sleep = exports.waitFor = exports.waitForAsync = exports.DEFAULT_FETCH_TIMEOUT_MS = exports.POLL_INTERVAL_MS = void 0;
const debug_1 = require("debug");
const BackOffStrategy_1 = require("./BackOffStrategy");
const errors_1 = require("./errors");
exports.POLL_INTERVAL_MS = 100;
exports.DEFAULT_FETCH_TIMEOUT_MS = 500;
const debug = debug_1.default('index-builder:util');
/**
 * Resolves when an async call resolves to true, and rejects if any call rejects.
 *
 *
 * @param condition Async condition to be satisfied
 * @param exit Force exit handle
 * @param pollInterval
 */
async function waitForAsync(condition, exit, pollInterval = exports.POLL_INTERVAL_MS) {
    let cond = await condition();
    while (!cond) {
        await sleep(pollInterval);
        cond = await condition();
        if (exit && exit()) {
            return;
        }
    }
}
exports.waitForAsync = waitForAsync;
/**
 * Returns a promise which resolves when a certain condition is met
 *
 * @param condition The promise resolves when `condition()` returns true
 * @param exit (optional) The promise rejects if exit() returns true
 * @param pollInterval (optimal) The sleep interval
 */
async function waitFor(condition, exit, pollInterval = exports.POLL_INTERVAL_MS) {
    return new Promise((resolve, reject) => {
        let timeout;
        const checkCondition = () => {
            if (exit && exit()) {
                if (timeout) {
                    clearTimeout(timeout);
                }
                reject(new Error('The exit condition has been triggered'));
                return;
            }
            if (condition()) {
                if (timeout) {
                    clearTimeout(timeout);
                }
                resolve();
            }
            else {
                timeout = setTimeout(checkCondition, pollInterval);
            }
        };
        checkCondition();
    });
}
exports.waitFor = waitFor;
/**
 * Sleep for a given amount of milliseconds
 *
 * @param time For how long to sleep
 */
async function sleep(timeMS) {
    await new Promise((resolve) => setTimeout(() => {
        resolve();
    }, timeMS));
}
exports.sleep = sleep;
/*
 * Await for the promise or reject after a timeout
 */
async function withTimeout(promiseFn, rejectMsg, timeoutMS) {
    // Create a promise that rejects in <ms> milliseconds
    const timeoutPromise = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
            clearTimeout(id);
            reject(new Error(`${rejectMsg || 'Execution time-out'}`));
        }, timeoutMS || exports.DEFAULT_FETCH_TIMEOUT_MS);
    });
    // Returns a race between our timeout and the passed in promise
    return Promise.race([promiseFn, timeoutPromise]).then((x) => x);
}
exports.withTimeout = withTimeout;
/**
 * Tries to resolve the given promise multiple times; gives up after the given number of retries.
 * If the number of retries is `-1` (default), then it retries ad infinitum.
 *
 * @param promiseFn Promise to resolve
 * @param retries Number of retries or -1 for infinite number of retries;
 */
async function retry(promiseFn, retries = -1, backoff = new BackOffStrategy_1.ExponentialBackOffStrategy()) {
    let result;
    let retriesLeft = retries;
    let error;
    while (result === undefined && retriesLeft !== 0) {
        try {
            result = await promiseFn();
            backoff.resetBackoffTime();
            return result;
        }
        catch (e) {
            error = new Error(e);
            await sleep(backoff.getBackOffMs());
            debug(`An error occured: ${JSON.stringify(e, null, 2)}. Retrying in ${backoff.getBackOffMs()}ms. 
            Number of retries left: ${retriesLeft}`);
            retriesLeft = retriesLeft > 0 ? retriesLeft - 1 : retriesLeft;
            backoff.registerFailure();
        }
    }
    backoff.resetBackoffTime();
    throw new Error(`Failed to resolve promise after ${retries} retries. Last error: ${errors_1.logError(error)}`);
}
exports.retry = retry;
async function retryWithTimeout(promiseFn, timeout, retries = -1, backoff = new BackOffStrategy_1.ExponentialBackOffStrategy()) {
    return await retry(() => {
        const prom = promiseFn();
        return withTimeout(prom, `Timed out: ${timeout} ms`, timeout);
    }, retries, backoff);
}
exports.retryWithTimeout = retryWithTimeout;
//# sourceMappingURL=wait-for.js.map