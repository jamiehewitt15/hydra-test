"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLSource = void 0;
const tslib_1 = require("tslib");
const graphql_request_1 = require("graphql-request");
const typedi_1 = require("typedi");
const debug_1 = require("debug");
const events_1 = require("events");
const debug = debug_1.default('index-builder:processor');
const GET_EVENTS_AFTER_QUERY = `
query GetEventsAfterID( $afterID: ID, $names: [String!]!, $fromBlock: Int, $toBlock: Int, $size: Int) {
  substrateEventsAfter(where: { name_in: $names, blockNumber_gte: $fromBlock, blockNumber_lte: $toBlock }, afterID: $afterID, limit: $size) {
    id
    name 
    method
    params {
      name
      type
      value
    }
    index 
    blockNumber
    extrinsic {
      method
      section
      versionInfo
      signer
      args
      signature
      hash
      tip
    }
  }
}
`;
// to be replaced with a ws subsription
const GET_INDEXER_HEAD = `
query {
  indexerStatus {
    head
  }
}
`;
let GraphQLSource = class GraphQLSource extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        const _endpoint = options.indexerEndpointURL || process.env.INDEXER_ENDPOINT_URL;
        if (!_endpoint) {
            throw new Error(`Indexer endpoint is not provided`);
        }
        debug(`Using Indexer API endpoint ${_endpoint}`);
        this.graphClient = new graphql_request_1.GraphQLClient(_endpoint);
    }
    // TODO: implement
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    subscribe(events) {
        throw new Error('Method not implemented.');
    }
    async indexerHead() {
        const status = await this.graphClient.request(GET_INDEXER_HEAD);
        return status.indexerStatus.head;
    }
    async nextBatch(filter, size) {
        debug(`Filter: ${JSON.stringify(filter, null, 2)}`);
        const data = await this.graphClient.request(GET_EVENTS_AFTER_QUERY, {
            size,
            names: filter.names,
            afterID: filter.afterID,
            fromBlock: filter.fromBlock,
            toBlock: filter.toBlock,
        });
        debug(`Fetched ${data.substrateEventsAfter.length} events`);
        debug(`Events: ${JSON.stringify(data, null, 2)} events`);
        return data.substrateEventsAfter;
    }
};
GraphQLSource = tslib_1.__decorate([
    tslib_1.__param(0, typedi_1.Inject('ProcessorOptions')),
    tslib_1.__metadata("design:paramtypes", [Object])
], GraphQLSource);
exports.GraphQLSource = GraphQLSource;
//# sourceMappingURL=GraphQLSource.js.map