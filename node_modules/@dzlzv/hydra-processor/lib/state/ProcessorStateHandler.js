"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessorStateHandler = void 0;
const tslib_1 = require("tslib");
const dal_1 = require("../db/dal");
const entities_1 = require("../entities");
const typeorm_1 = require("typeorm");
const typedi_1 = require("typedi");
const events_1 = require("events");
const debug_1 = require("debug");
const assert = require("assert");
const debug = debug_1.default('index-builder:processor-state-handler');
let ProcessorStateHandler = class ProcessorStateHandler extends events_1.EventEmitter {
    constructor(processorID = 'hydra-processor') {
        super();
        this.processorID = processorID;
        typedi_1.default.set('ProcessorStateHandler', this);
    }
    async persist(state) {
        assert(state.lastProcessedEvent, 'Cannot persist undefined event ID');
        const processed = new entities_1.ProcessedEventsLogEntity();
        processed.processor = this.processorID;
        processed.eventId = state.lastProcessedEvent;
        processed.lastScannedBlock = state.lastScannedBlock;
        await typeorm_1.getRepository('ProcessedEventsLogEntity').save(processed);
        this.emit('STATE_CHANGE', state);
    }
    async init(atBlock = 0) {
        if (atBlock > 0) {
            debug(`Got block height hint: ${atBlock}`);
        }
        const lastState = await dal_1.loadState(this.processorID);
        if (lastState) {
            debug(`Found the most recent processed event ${lastState.eventId}`);
            if (atBlock > lastState.lastScannedBlock) {
                debug(`WARNING! Existing processed history detected on the database!
          Last processed event id ${lastState.eventId}. The indexer 
          will continue from block ${lastState.lastScannedBlock} and ignore the block height hint.`);
            }
            return {
                lastProcessedEvent: lastState.eventId,
                lastScannedBlock: lastState.lastScannedBlock,
            };
        }
        const state = {
            lastScannedBlock: atBlock,
            lastProcessedEvent: undefined,
        };
        this.emit('STATE_CHANGE', state);
        return state;
    }
};
ProcessorStateHandler = tslib_1.__decorate([
    typedi_1.Service('ProcessorStateHander'),
    tslib_1.__metadata("design:paramtypes", [Object])
], ProcessorStateHandler);
exports.ProcessorStateHandler = ProcessorStateHandler;
//# sourceMappingURL=ProcessorStateHandler.js.map