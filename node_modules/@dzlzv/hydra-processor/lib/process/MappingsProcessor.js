"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappingsProcessor = void 0;
const tslib_1 = require("tslib");
const debug_1 = require("debug");
const hydra_db_utils_1 = require("@dzlzv/hydra-db-utils");
const typedi_1 = require("typedi");
const ingest_1 = require("../ingest");
const HandlerLookupService_1 = require("./HandlerLookupService");
const hydra_common_1 = require("@dzlzv/hydra-common");
const state_1 = require("../state");
const processor_consts_1 = require("./processor-consts");
const events_1 = require("events");
const debug = debug_1.default('index-builder:processor');
let MappingsProcessor = class MappingsProcessor extends events_1.EventEmitter {
    constructor(options, eventsSource = new ingest_1.GraphQLSource(options), handlerLookup = new HandlerLookupService_1.HandlerLookupService(options), stateHandler = new state_1.ProcessorStateHandler(options.name || processor_consts_1.DEFAULT_PROCESSOR_NAME)) {
        super();
        this.options = options;
        this.eventsSource = eventsSource;
        this.handlerLookup = handlerLookup;
        this.stateHandler = stateHandler;
        this._started = false;
        this._name = processor_consts_1.DEFAULT_PROCESSOR_NAME;
        // TODO: uncomment this block when eventSource will emit
        // this.eventsSource.on('NewIndexerHead', (h: number) => {
        //   debug(`New Indexer Head: ${h}`)
        //   this.indexerHead = h
        // });
        // For now, simply update indexerHead regularly
        setInterval(() => {
            this.eventsSource
                .indexerHead()
                .then((h) => {
                debug(`New indexer head: ${h}`);
                this.indexerHead = h;
            })
                .catch((e) => debug(`Error fetching new indexer head: ${hydra_common_1.logError(e)}`));
        }, processor_consts_1.PROCESSOR_POLL_INTERVAL); // every minute
    }
    async start() {
        debug('Spawned the processor');
        this.state = await this.stateHandler.init(this.options.atBlock);
        this.indexerHead = await this.eventsSource.indexerHead();
        this.currentFilter = {
            afterID: this.state.lastProcessedEvent,
            fromBlock: this.state.lastScannedBlock,
            toBlock: Math.min(this.state.lastScannedBlock + processor_consts_1.BLOCK_WINDOW, this.indexerHead),
            names: this.handlerLookup.eventsToHandle(),
        };
        this._started = true;
        await hydra_common_1.waitFor(() => {
            debug(`Waiting for the indexer head to be initialized`);
            return this.indexerHead >= 0;
        });
        await this.processingLoop();
    }
    stop() {
        this._started = false;
    }
    async nextFilter() {
        debug(`Indexer Head: ${this.indexerHead} Last Scanned Block: ${this.state.lastScannedBlock}`);
        // here we should eventually listen only to the events
        // For now, we simply wait until the indexer go for at least {MINIMUM_BLOCKS_AHEAD}
        // blocks ahead of the last scanned block
        await hydra_common_1.waitFor(() => this.indexerHead - this.state.lastScannedBlock > processor_consts_1.MINIMUM_BLOCKS_AHEAD, () => !this._started);
        this.currentFilter.fromBlock = this.state.lastScannedBlock;
        this.currentFilter.toBlock = Math.min(this.currentFilter.fromBlock + processor_consts_1.BLOCK_WINDOW, this.indexerHead);
        this.currentFilter.afterID = this.state.lastProcessedEvent;
        // debug(`Next filter: ${JSON.stringify(this.currentFilter, null, 2)}`);
        return this.currentFilter;
    }
    // Long running loop where events are fetched and the mappings are applied
    async processingLoop() {
        while (this._started) {
            try {
                const nextFilter = await this.nextFilter();
                const events = await this.eventsSource.nextBatch(nextFilter, processor_consts_1.BATCH_SIZE);
                debug(`Processing new batch of events of size: ${events.length}`);
                if (events.length > 0) {
                    await this.processEventBlock(events);
                }
                else {
                    // If there is nothing to process, wait and update the indexer head
                    // TODO: we should really subsribe to new indexer heads here and update accordingly
                    this.state.lastScannedBlock = this.currentFilter.toBlock;
                    // if we haven't found anything matching just take the genesis
                    this.state.lastProcessedEvent =
                        this.state.lastProcessedEvent || hydra_common_1.formatEventId(0, 0);
                    await this.stateHandler.persist(this.state);
                }
            }
            catch (e) {
                console.error(`Stopping the proccessor due to errors: ${hydra_common_1.logError(e)}`);
                this.stop();
                throw new Error(e);
            }
        }
        debug(`The processor has been stopped`);
    }
    async processEventBlock(queryEventBlock) {
        for (const event of queryEventBlock) {
            await hydra_db_utils_1.doInTransaction(async (queryRunner) => {
                debug(`Processing event ${event.name}, 
          id: ${event.id}`);
                debug(`JSON: ${JSON.stringify(event, null, 2)}`);
                const handler = this.handlerLookup.lookupHandler(event.name);
                await handler(hydra_db_utils_1.makeDatabaseManager(queryRunner.manager), event);
                this.state.lastProcessedEvent = event.id;
                this.state.lastScannedBlock = event.blockNumber;
                await this.stateHandler.persist(this.state);
                debug(`Event ${event.id} done`);
            });
            this.emit('PROCESSED_EVENT', event);
        }
    }
    get name() {
        return this._name;
    }
};
MappingsProcessor = tslib_1.__decorate([
    typedi_1.Service('MappingsProcessor'),
    tslib_1.__param(0, typedi_1.Inject('ProcessorOptions')),
    tslib_1.__param(1, typedi_1.Inject('ProcessorSource')),
    tslib_1.__param(2, typedi_1.Inject()),
    tslib_1.__param(3, typedi_1.Inject('ProcessorStateHandler')),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object])
], MappingsProcessor);
exports.MappingsProcessor = MappingsProcessor;
//# sourceMappingURL=MappingsProcessor.js.map